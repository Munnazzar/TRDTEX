{
  "InitTemplate": {
    "prefix": "cpR",
    "body": [
      "#ifdef ONPC",
      "#define _GLIBCXX_DEBUG",
      "#endif",
      "#include <bits/stdc++.h>",
      "#ifdef ONPC",
      "#include \"debug.hpp\"",
      "#else",
      "#define debug(...) 42",
      "#endif",
      "using namespace std;",
      "#define int long long",
      "",
      "void solve()",
      "{",
      "\t$0",
      "}",
      "",
      "int32_t main()",
      "{",
      "    ios::sync_with_stdio(0);",
      "    cin.tie(0);",
      "    int t = 1;",
      "    // cin >> t;",
      "    for (int i = 0; i < t; ++i)",
      "    {",
      "        debug(i);",
      "        solve();",
      "    }",
      "    return 0;",
      "}",
      ""
    ],
    "description": "InitTemplate"
  },
  "Competitive Programming Template": {
    "prefix": "cpT",
    "body": [
      "#ifdef ONPC",
      "#define _GLIBCXX_DEBUG",
      "#endif",
      "#include <bits/stdc++.h>",
      "#define pii pair<int,int>",
      "using namespace std;",
      "",
      "mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());",
      "",
      "void solve() {",
      "\t$0",
      "\treturn;",
      "}",
      "",
      "signed main() {",
      "\tios::sync_with_stdio(0);",
      "\tcin.tie(0);",
      "\tint t = 1;",
      "\t#ifdef ONPC",
      "\t\tfreopen(\"input.txt\", \"r\", stdin);",
      "\t#endif",
      "\t// cin >> t;",
      "\tfor (int i = 0; i < t; ++i) {",
      "\t\tsolve();",
      "\t}",
      "\t#ifdef ONPC",
      "\t\tcerr << endl << \"finished in \" << clock() * 1.0 / CLOCKS_PER_SEC << \" sec\" << endl;",
      "\t#endif",
      "\treturn 0;",
      "}"
    ],
    "description": "Competitive programming template"
  },
  "For Loop": {
    "prefix": "for",
    "body": [
      "for (int ${1:i} = 0; $1 < ${2:n}; $1++) {",
      "\t$0",
      "}"
    ],
    "description": "For loop"
  },
  "For Auto": {
    "prefix": "fora",
    "body": [
      "for (auto ${1:in} : $2) {",
      "\t$0",
      "}"
    ],
    "description": "For auto loop"
  },
  "Vector": {
    "prefix": "vec",
    "body": [
      "vector<${1:int}> ${2:in};$0"
    ],
    "description": "Vector declaration"
  },
  "Vector of Vectors": {
    "prefix": "vvi",
    "body": [
      "vector<vector<${1:int}>> ${2:in}();$0"
    ],
    "description": "2D Vector declaration"
  },
  "All": {
    "prefix": "all",
    "body": [
      "${1:in}.begin(), $1.end()$0"
    ],
    "description": "Shortcut for using .begin() and .end()"
  },
  "Read Vector": {
    "prefix": "readvec",
    "body": [
      "vector<${1:int}> ${2:arr}(${3:n});",
      "for ($1 &val : $2) {",
      "\tcin >> val;",
      "}",
      "$0"
    ],
    "description": "Read a vector"
  },
  "Block": {
    "prefix": "{",
    "body": [
      "{",
      "\t$0",
      "}"
    ],
    "description": "Block"
  },
  "Main Function": {
    "prefix": "main",
    "body": [
      "int main(int argc, char *argv[]) {",
      "\t${0}",
      "\treturn 0;",
      "}"
    ],
    "description": "Main function"
  },
  "Print Something": {
    "prefix": "prints",
    "body": [
      "cout << $1 << \" \";"
    ],
    "description": "Print something"
  },
  "Print with New Line": {
    "prefix": "printn",
    "body": [
      "cout << $1 << endl;"
    ],
    "description": "Print with new line"
  },
  "Push Back": {
    "prefix": "pb",
    "body": [
      "push_back($1);$0"
    ],
    "description": "Push back"
  },
  "dsu": {
    "prefix": "dsu",
    "body": [
      "struct DSU",
      "{",
      "  vector<int> par, rnk, sz;",
      "  int c;",
      "  DSU(int n) : par(n + 1), rnk(n + 1, 0), sz(n + 1, 1), c(n)",
      "  {",
      "    for (int i = 1; i <= n; ++i)",
      "      par[i] = i;",
      "  }",
      "  int find(int i)",
      "  {",
      "    return (par[i] == i ? i : (par[i] = find(par[i])));",
      "  }",
      "  bool same(int i, int j)",
      "  {",
      "    return find(i) == find(j);",
      "  }",
      "  int get_size(int i)",
      "  {",
      "    return sz[find(i)];",
      "  }",
      "  int count()",
      "  {",
      "    return c; // connected components",
      "  }",
      "  int merge(int i, int j)",
      "  {",
      "    if ((i = find(i)) == (j = find(j)))",
      "      return -1;",
      "    else",
      "      --c;",
      "    if (rnk[i] > rnk[j])",
      "      swap(i, j);",
      "    par[i] = j;",
      "    sz[j] += sz[i];",
      "    if (rnk[i] == rnk[j])",
      "      rnk[j]++;",
      "    return j;",
      "  }",
      "};"
    ],
    "description": "dsu"
  },
  "Segment Tree (Sum)": {
    "prefix": "segSum",
    "body": [
      "vector<int> arr(N, 0);",
      "vector<int> seg(4 * N, -1);",
      "",
      "void build(int index, int low, int high) {",
      "\tif (low == high) {",
      "\t\tseg[index] = arr[low];",
      "\t\treturn;",
      "\t}",
      "\tint mid = low + (high - low) / 2;",
      "\tbuild(index * 2 + 1, low, mid);",
      "\tbuild(index * 2 + 2, mid + 1, high);",
      "\tseg[index] = seg[index * 2 + 1] + seg[index * 2 + 2];",
      "\treturn;",
      "}",
      "",
      "int query(int index, int low, int high, int l, int r) {",
      "\tif (low >= l && high <= r) {",
      "\t\treturn seg[index];",
      "\t}",
      "\tif (high < l || low > r) {",
      "\t\treturn 0;",
      "\t}",
      "\tint mid = low + (high - low) / 2;",
      "\treturn query(index * 2 + 1, low, mid, l, r) + query(index * 2 + 2, mid + 1, high, l, r);",
      "}"
    ],
    "description": "Segment tree (Sum)"
  },
  "Segment Tree Minimum": {
    "prefix": "segMin",
    "body": [
      "vector<int> arr(N, 0);",
      "vector<int> seg(4 * N, -1);",
      "",
      "void build(int index, int low, int high) {",
      "    if (low == high) {",
      "        seg[index] = arr[low];",
      "        return;",
      "    }",
      "    int mid = low + (high - low) / 2;",
      "    build(index * 2 + 1, low, mid);",
      "    build(index * 2 + 2, mid + 1, high);",
      "    seg[index] = min(seg[index * 2 + 1], seg[index * 2 + 2]);",
      "    return;",
      "}",
      "",
      "int query(int index, int low, int high, int l, int r) {",
      "    if (low >= l && high <= r) {",
      "        return seg[index];",
      "    }",
      "    if (high < l || low > r) {",
      "        return INT_MAX;",
      "    }",
      "    int mid = low + (high - low) / 2;",
      "    return min(query(index * 2 + 1, low, mid, l, r), query(index * 2 + 2, mid + 1, high, l, r));",
      "}"
    ],
    "description": "Segment Tree for Minimum Range Queries"
  },
  "Math Stuff": {
    "prefix": "maths",
    "body": [
      "class math {",
      "public:",
      "    long long binPow(long long a, long long b, const long long m) {",
      "        a %= m;",
      "        long long res = 1;",
      "        while (b > 0) {",
      "            if (b & 1)",
      "                res = res * a % m;",
      "            a = a * a % m;",
      "            b >>= 1;",
      "        }",
      "        return res;",
      "    }",
      "};"
    ],
    "description": "Math utilities including binary exponentiation"
  },
  "FFT and Variants": {
    "prefix": "fftAndVariants",
    "body": [
      "class fftAndVariants {",
      "public:",
      "    ll powM(ll x, ll y, ll m) {",
      "        ll ans = 1, r = 1;",
      "        x %= m;",
      "        while (r > 0 && r <= y) {",
      "            if (r & y) {",
      "                ans *= x;",
      "                ans %= m;",
      "            }",
      "            r <<= 1;",
      "            x *= x;",
      "            x %= m;",
      "        }",
      "        return ans;",
      "    }",
      "",
      "    ll modI(ll a, ll m) {",
      "        ll m0 = m, y = 0, x = 1;",
      "        if (m == 1)",
      "            return 0;",
      "        while (a > 1) {",
      "            ll q = a / m;",
      "            ll t = m;",
      "            m = a % m;",
      "            a = t;",
      "            t = y;",
      "            y = x - q * y;",
      "            x = t;",
      "        }",
      "        if (x < 0)",
      "            x += m0;",
      "        return x;",
      "    }",
      "",
      "    void Miden(ll **p1, ll n) {",
      "        ll(*x)[n] = (ll(*)[n])p1;",
      "        for (ll i = 0; i < n; ++i) {",
      "            for (ll j = 0; j < n; ++j) {",
      "                x[i][j] = 0;",
      "            }",
      "            x[i][i] = 1;",
      "        }",
      "        return;",
      "    }",
      "",
      "    void Mmult(ll **p1, ll **p2, ll **ans, ll x, ll y, ll z, ll m) {",
      "        ll(*a)[y] = (ll(*)[y])p1;",
      "        ll(*b)[z] = (ll(*)[z])p2;",
      "        ll(*c)[z] = (ll(*)[z])ans;",
      "        for (ll i = 0; i < x; ++i) {",
      "            for (ll j = 0; j < z; ++j) {",
      "                c[i][j] = 0;",
      "                for (ll k = 0; k < y; ++k) {",
      "                    c[i][j] += a[i][k] * b[k][j];",
      "                    c[i][j] %= m;",
      "                }",
      "            }",
      "        }",
      "        return;",
      "    }",
      "",
      "    void Mpow(ll **p1, ll **ans, ll n, ll y, ll m) {",
      "        if (y == 0) {",
      "            Miden(ans, n);",
      "            return;",
      "        }",
      "        ll t[n][n];",
      "        Mpow(p1, (ll **)t, n, y / 2, m);",
      "        ll z[n][n];",
      "        Mmult((ll **)t, (ll **)t, (ll **)z, n, n, n, m);",
      "        if (y % 2) {",
      "            Mmult((ll **)z, p1, ans, n, n, n, m);",
      "        } else {",
      "            Miden((ll **)t, n);",
      "            Mmult((ll **)z, (ll **)t, ans, n, n, n, m);",
      "        }",
      "        return;",
      "    }",
      "",
      "    bool isprime(ll n) {",
      "        if (n < 2)",
      "            return false;",
      "        for (ll x : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {",
      "            if (n == x)",
      "                return true;",
      "            bool flag = true;",
      "            ll r = 1;",
      "            ll t = 1;",
      "            while (r <= ((n - 1) >> __builtin_ctzll(n - 1))) {",
      "                if (r & ((n - 1) >> __builtin_ctzll(n - 1)))",
      "                    t = ((__int128)t * x) % n;",
      "                x = ((__int128)x * x) % n;",
      "                r <<= 1;",
      "            }",
      "            if (t == 1 || t == n - 1)",
      "                flag = false;",
      "            for (r = 0; r < __builtin_ctzll(n - 1); r++) {",
      "                t = ((__int128)t * t) % n;",
      "                if (t == n - 1)",
      "                    flag = false;",
      "            }",
      "            if (flag)",
      "                return false;",
      "        }",
      "        return true;",
      "    }",
      "",
      "    ll PrimRoot(ll p, ll x) {",
      "        vector<ll> v;",
      "        ll t = p - 1;",
      "        for (ll i = 2; i <= t; ++i) {",
      "            if (i * i > t)",
      "                break;",
      "            if (t % i == 0) {",
      "                v.push_back((p - 1) / i);",
      "                while (t % i == 0) {",
      "                    t /= i;",
      "                }",
      "            }",
      "        }",
      "        if (t > 1)",
      "            v.push_back((p - 1) / t);",
      "        for (ll i = x + 1; i < p; ++i) {",
      "            ll flag = 0;",
      "            for (ll j = 0; j < (ll)v.size(); ++j) {",
      "                if (powM(i, v[j], p) == 1) {",
      "                    flag = 1;",
      "                    break;",
      "                }",
      "            }",
      "            if (flag == 0) {",
      "                return i;",
      "            }",
      "        }",
      "        return 0;",
      "    }",
      "",
      "    void fft(vector<ll> &a, ll n, bool invert, ll m, ll x) {",
      "        for (ll i = 0; i < n; ++i) {",
      "            ll y = 0;",
      "            for (ll j = 0; j < __builtin_ctzll(n); ++j) {",
      "                if ((1LL << j) & i) {",
      "                    y |= (1LL << (__builtin_ctzll(n) - j - 1));",
      "                }",
      "            }",
      "            if (y > i) {",
      "                swap(a[i], a[y]);",
      "            }",
      "        }",
      "        if (invert)",
      "            x = modI(x, m);",
      "        for (ll s = 1; s <= __builtin_ctzll(n); ++s) {",
      "            ll y = powM(x, (n / (1LL << s)), m);",
      "            for (ll j = 0; j < (n / (1LL << s)); ++j) {",
      "                ll r = 1;",
      "                for (ll i = 0; i < (1LL << (s - 1)); ++i) {",
      "                    ll u = a[i + j * (1LL << s)];",
      "                    ll v = (r * a[i + j * (1LL << s) + (1LL << (s - 1))]) % m;",
      "                    a[i + j * (1LL << s)] = u + v;",
      "                    if (a[i + j * (1LL << s)] > m)",
      "                        a[i + j * (1LL << s)] -= m;",
      "                    a[i + j * (1LL << s) + (1LL << (s - 1))] = u - v;",
      "                    if (a[i + j * (1LL << s) + (1LL << (s - 1))] < 0)",
      "                        a[i + j * (1LL << s) + (1LL << (s - 1))] += m;",
      "                    r *= y;",
      "                    r %= m;",
      "                }",
      "            }",
      "        }",
      "        if (invert) {",
      "            ll invn = modI(n, m);",
      "            for (ll i = 0; i < n; ++i) {",
      "                a[i] = (a[i] * invn) % m;",
      "            }",
      "        }",
      "        return;",
      "    }",
      "",
      "    void PolyMult(vector<ll> &a, vector<ll> &b, vector<ll> &v, ll m, ll x) {",
      "        ll n = 1;",
      "        while (n < ((ll)a.size()) + ((ll)b.size())) {",
      "            n <<= 1;",
      "        }",
      "        vector<ll> fa(a.begin(), a.end());",
      "        fa.resize(n, 0);",
      "        vector<ll> fb(b.begin(), b.end());",
      "        fb.resize(n, 0);",
      "        ll y = powM(x, (m - 1) / n, m);",
      "        fft(fa, n, false, m, y);",
      "        fft(fb, n, false, m, y);",
      "        v.resize(n, 0);",
      "        for (ll i = 0; i < n; ++i) {",
      "            v[i] = ((fa[i] * fb[i]) % m);",
      "        }",
      "        fft(v, n, true, m, y);",
      "        v.resize(((ll)a.size()) + ((ll)b.size()) - 1, 0LL);",
      "        return;",
      "    }",
      "",
      "    void PolyInverse(vector<ll> &a, vector<ll> &v, ll n, ll m, ll x) {",
      "        v.clear();",
      "        v.push_back(modI(a[0], m));",
      "        while (((ll)v.size()) < n) {",
      "            ll tmpsz = (((ll)v.size()) << 1);",
      "            vector<ll> tmpa(tmpsz, 0LL);",
      "            for (ll i = 0; i < min(((ll)a.size()), tmpsz); ++i) {",
      "                tmpa[i] = a[i];",
      "            }",
      "            vector<ll> tmppr;",
      "            PolyMult(tmpa, v, tmppr, m, x);",
      "            tmppr.resize(tmpsz, 0LL);",
      "            for (ll i = 0; i < tmpsz; ++i) {",
      "                tmppr[i] = ((m - tmppr[i]) % m);",
      "            }",
      "            tmppr[0] = ((tmppr[0] + 2) % m);",
      "            vector<ll> tmpv(v.begin(), v.end());",
      "            PolyMult(tmppr, tmpv, v, m, x);",
      "            v.resize(tmpsz, 0LL);",
      "        }",
      "        v.resize(n, 0LL);",
      "        return;",
      "    }",
      "",
      "    void PolyDiv(vector<ll> &a, vector<ll> &b, vector<ll> &q, vector<ll> &r, ll m, ll x) {",
      "        if (((ll)a.size()) < ((ll)b.size())) {",
      "            r = a;",
      "            r.resize(((ll)b.size()) - 1, 0LL);",
      "            q.clear();",
      "            q.push_back(0LL);",
      "            return;",
      "        }",
      "        vector<ll> ra(((ll)a.size()) - ((ll)b.size()) + 1, 0LL);",
      "        for (ll i = 0; i < ((ll)a.size()) - ((ll)b.size()) + 1; ++i) {",
      "            ra[i] = a[((ll)a.size()) - 1 - i];",
      "        }",
      "        vector<ll> rb(((ll)b.size()), 0LL);",
      "        for (ll i = 0; i < ((ll)b.size()); ++i) {",
      "            rb[i] = b[((ll)b.size()) - 1 - i];",
      "        }",
      "        vector<ll> irb;",
      "        PolyInverse(rb, irb, ((ll)a.size()) - ((ll)b.size()) + 1, m, x);",
      "        vector<ll> rq;",
      "        PolyMult(ra, irb, rq, m, x);",
      "        rq.resize(((ll)a.size()) - ((ll)b.size()) + 1, 0LL);",
      "        q.resize(((ll)a.size()) - ((ll)b.size()) + 1, 0LL);",
      "        for (ll i = 0; i < ((ll)rq.size()); ++i) {",
      "            q[i] = rq[((ll)rq.size()) - 1 - i];",
      "        }",
      "        vector<ll> tmppr;",
      "        PolyMult(b, q, tmppr, m, x);",
      "        r.resize(((ll)b.size()) - 1, 0LL);",
      "        for (ll i = 0; i < ((ll)r.size()); ++i) {",
      "            r[i] = ((a[i] + m - tmppr[i]) % m);",
      "        }",
      "        return;",
      "    }",
      "};"
    ],
    "description": "FFT and Polynomial Utilities"
  },
  "segmentTreeClass": {
    "prefix": "seggy",
    "body": [
      "",
      "class SegmentTree {",
      "    vector<int> arr;",
      "    vector<int> seg;",
      "    int N;",
      "",
      "public:",
      "    SegmentTree(int n) {",
      "        N = n;",
      "        arr.assign(N, 0);",
      "        seg.assign(4 * N, 0);",
      "    }",
      "",
      "    void setArray(const vector<int>& input) {",
      "        arr = input;",
      "    }",
      "",
      "    void build(int index = 0, int low = 0, int high = -1) {",
      "        if (high == -1) high = N - 1;",
      "        if (low == high) {",
      "            seg[index] = arr[low];",
      "            return;",
      "        }",
      "        int mid = low + (high - low) / 2;",
      "        build(index * 2 + 1, low, mid);",
      "        build(index * 2 + 2, mid + 1, high);",
      "        seg[index] = seg[index * 2 + 1] & seg[index * 2 + 2];",
      "    }",
      "",
      "    int query(int l, int r, int index = 0, int low = 0, int high = -1) {",
      "        if (high == -1) high = N - 1;",
      "",
      "        if (low >= l && high <= r) return seg[index];",
      "",
      "        if (high < l || low > r) return (1LL<<62)-1;",
      "",
      "        int mid = low + (high - low) / 2;",
      "        int left = query(l, r, index*2+1, low, mid);",
      "        int right = query(l, r, index*2+2, mid+1, high);",
      "",
      "        return left&right;",
      "    }",
      "};",
      ""
    ],
    "description": "segmentTreeClass"
  },
  "custom Hash function": {
    "prefix": "customHash",
    "body": [
      "struct custom_hash {",
      "    static uint64_t splitmix64(uint64_t x) {",
      "        // http://xorshift.di.unimi.it/splitmix64.c",
      "        x += 0x9e3779b97f4a7c15;",
      "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
      "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
      "        return x ^ (x >> 31);",
      "    }",
      "",
      "    size_t operator()(uint64_t x) const {",
      "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
      "        return splitmix64(x + FIXED_RANDOM);",
      "    }",
      "};"
    ],
    "description": ""
  },
  "Polynomial Rolling Hash": {
    "prefix": "polyHash",
    "body": [
      "#define MOD(a, b) ((a % b) + b) % b",
      "const int MODH1 = 1e9 + 7;",
      "const int BASE1 = 911;",
      "const int MODH2 = 1e9 + 9;",
      "const int BASE2 = 3571;",
      "",
      "struct RollingHash",
      "{",
      "    int n;",
      "    vector<int> H1, P1;",
      "    vector<int> H2, P2;",
      "",
      "    RollingHash(const string &s)",
      "    {",
      "        n = s.size();",
      "        H1.assign(n + 1, 0);",
      "        P1.assign(n + 1, 1);",
      "        H2.assign(n + 1, 0);",
      "        P2.assign(n + 1, 1);",
      "",
      "        for (int i = 0; i < n; ++i)",
      "        {",
      "            int val = s[i] - 'a' + 1;",
      "            H1[i + 1] = (H1[i] * BASE1 + val) % MODH1;",
      "            P1[i + 1] = (P1[i] * BASE1) % MODH1;",
      "",
      "            H2[i + 1] = (H2[i] * BASE2 + val) % MODH2;",
      "            P2[i + 1] = (P2[i] * BASE2) % MODH2;",
      "        }",
      "    }",
      "",
      "    pair<int, int> get(int l, int r)",
      "    {",
      "        int x1 = MOD(H1[r] - H1[l] * P1[r - l], MODH1);",
      "        int x2 = MOD(H2[r] - H2[l] * P2[r - l], MODH2);",
      "        return {x1, x2};",
      "    }",
      "};",
      ""
    ],
    "description": ""
  },
  "Advance Polynomial hashing": {
    "prefix": "PolyHashAd",
    "body": [
      "static int gen_base(int lo = 256, int hi = 1000000000)",
      "{",
      "    static std::mt19937_64 rng((uint64_t)chrono::high_resolution_clock::now().time_since_epoch().count());",
      "    std::uniform_int_distribution<int> dist(lo + 1, hi - 1);",
      "    int b = dist(rng);",
      "    if (b % 2 == 0)",
      "        --b;",
      "    return max(257ll, b); // ensure > 256 and odd",
      "}",
      "",
      "struct PolyHash",
      "{",
      "    // two-prime/ull hybrid rolling hash",
      "    static const int MOD = 1000000007; // prime",
      "    int base;                          // hash base (must be same for comparisons)",
      "    int n;",
      "    vector<int> Hmod, Pmod; // mod hash and powers",
      "    vector<ull> Hull, Pull; // ull hash and powers",
      "",
      "    PolyHash() : base(0), n(0) {}",
      "",
      "    // Construct & init with a base (if base==0 will gen one)",
      "    PolyHash(const string &s, int base_ = 0)",
      "    {",
      "        if (base_ == 0)",
      "            base_ = gen_base();",
      "        init(s, base_);",
      "    }",
      "",
      "    void init(const string &s, int base_)",
      "    {",
      "        base = base_;",
      "        n = (int)s.size();",
      "        Hmod.assign(n + 1, 0);",
      "        Pmod.assign(n + 1, 1);",
      "        Hull.assign(n + 1, 0);",
      "        Pull.assign(n + 1, 1);",
      "",
      "        for (int i = 0; i < n; ++i)",
      "        {",
      "            int v = (unsigned char)s[i]; // keep >0; works for any ascii/bytes",
      "            Hmod[i + 1] = ((1LL * Hmod[i] * base) + v) % MOD;",
      "            Pmod[i + 1] = (1LL * Pmod[i] * base) % MOD;",
      "",
      "            Hull[i + 1] = Hull[i] * (ull)base + (ull)v; // mod 2^64 (wrap)",
      "            Pull[i + 1] = Pull[i] * (ull)base;",
      "        }",
      "    }",
      "",
      "    // Return pair-hash for substring s[l .. l+len-1] (0-based, [l, l+len))",
      "    pair<int, ull> get(int l, int len) const",
      "    {",
      "        int r = l + len;",
      "        int x1 = (Hmod[r] - (int)((1LL * Hmod[l] * Pmod[len]) % MOD));",
      "        if (x1 < 0)",
      "            x1 += MOD;",
      "        ull x2 = Hull[r] - Hull[l] * Pull[len];",
      "        return {x1, x2};",
      "    }",
      "    pair<int, ull> get_excluding(int L, int R) const",
      "    {",
      "        if (n == 0)",
      "            return {0, 0};",
      "        // clamp L,R into [0,n-1]",
      "        if (L < 0)",
      "            L = 0;",
      "        if (R >= n)",
      "            R = n - 1;",
      "        if (L > R)",
      "        { // nothing to exclude -> full string",
      "            return get(0, n);",
      "        }",
      "        int left_len = L;          // length of prefix kept",
      "        int right_len = n - R - 1; // length of suffix kept",
      "",
      "        // prefix hash (may be (0,0) if left_len==0)",
      "        auto left_hash = get(0, left_len);",
      "        // suffix hash (may be (0,0) if right_len==0)",
      "        auto right_hash = get(R + 1, right_len);",
      "",
      "        // combined = left * base^{right_len} + right",
      "        int combined_mod = ((1LL * left_hash.first * Pmod[right_len]) % MOD + right_hash.first) % MOD;",
      "        ull combined_ull = left_hash.second * Pull[right_len] + right_hash.second;",
      "        return {combined_mod, combined_ull};",
      "    }",
      "};"
    ],
    "description": "Advance Polynomial hashing"
  },
  "Pair Hash function": {
    "prefix": "pairHash",
    "body": [
      "struct custom_hash",
      "{",
      "    static uint64_t splitmix64(uint64_t x)",
      "    {",
      "        // http://xorshift.di.unimi.it/splitmix64.c",
      "        x += 0x9e3779b97f4a7c15ULL;",
      "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9ULL;",
      "        x = (x ^ (x >> 27)) * 0x94d049bb133111ebULL;",
      "        return x ^ (x >> 31);",
      "    }",
      "",
      "    size_t operator()(uint64_t x) const noexcept",
      "    {",
      "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
      "        return (size_t)splitmix64(x + FIXED_RANDOM);",
      "    }",
      "};",
      "",
      "// Generic pair-hash that uses custom_hash for each component and combines them.",
      "// Works for pair<T1,T2> where T1,T2 are integral (or castable to uint64_t).",
      "template <typename T1, typename T2>",
      "struct pair_hash",
      "{",
      "    size_t operator()(const pair<T1, T2> &p) const noexcept",
      "    {",
      "        // Hash each half with custom_hash",
      "        const auto h1 = custom_hash{}(static_cast<uint64_t>(p.first));",
      "        const auto h2 = custom_hash{}(static_cast<uint64_t>(p.second));",
      "        // combine using boost-like hash_combine",
      "        return h1 ^ (h2 + 0x9e3779b97f4a7c15ULL + (h1 << 6) + (h1 >> 2));",
      "    }",
      "};"
    ],
    "description": "Pair Hash function"
  },
  "Point": {
    "prefix": "point",
    "body": [
      "template <class T> int sgn(T x) { return (x > 0) - (x < 0); }",
      "template<class T>",
      "struct Point {",
    "	typedef Point P;",
    "	T x, y;",
    "	explicit Point(T x=0, T y=0) : x(x), y(y) {}",
    "	bool operator<(P p) const { return tie(x,y) < tie(p.x,p.y); }",
    "	bool operator==(P p) const { return tie(x,y)==tie(p.x,p.y); }",
    "	P operator+(P p) const { return P(x+p.x, y+p.y); }",
    "	P operator-(P p) const { return P(x-p.x, y-p.y); }",
    "	P operator*(T d) const { return P(x*d, y*d); }",
    "	P operator/(T d) const { return P(x/d, y/d); }",
    "	T dot(P p) const { return x*p.x + y*p.y; }",
    "	T cross(P p) const { return x*p.y - y*p.x; }",
    "	T cross(P a, P b) const { return (a-*this).cross(b-*this); }",
    "	T dist2() const { return x*x + y*y; }",
    "	double dist() const { return sqrt((double)dist2()); }",
    "	// angle to x-axis in interval [-pi, pi]",
    "	double angle() const { return atan2(y, x); }",
    "	P unit() const { return *this/dist(); } // makes dist()=1",
    "	P perp() const { return P(-y, x); } // rotates +90 degrees",
    "	P normal() const { return perp().unit(); }",
    "	// returns point rotated 'a' radians ccw around the origin",
    "	P rotate(double a) const {",
    "		return P(x*cos(a)-y*sin(a),x*sin(a)+y*cos(a)); }",
    "	friend ostream& operator<<(ostream& os, P p) {",
    "		return os << \"(\" << p.x << \",\" << p.y << \")\"; }",
      "};"
    ],
    "description": "Point"
  },
  "manacher Algo": {
    "prefix": "manacher",
    "body": [
      "#pragma once",
      "",
      "array<vi, 2> manacher(const string& s) {",
    "	int n = sz(s);",
    "	array<vi,2> p = {vi(n+1), vi(n)};",
    "	rep(z,0,2) for (int i=0,l=0,r=0; i < n; i++) {",
    "		int t = r-i+!z;",
    "		if (i<r) p[z][i] = min(t, p[z][l+t]);",
    "		int L = i-p[z][i], R = i+p[z][i]-!z;",
    "		while (L>=1 && R+1<n && s[L-1] == s[R+1])",
    "			p[z][i]++, L--, R++;",
    "		if (R>r) l=L, r=R;",
    "	}",
    "	return p;",
      "}"
    ],
    "description": ""
  },
  "": {
    "prefix": "ash",
    "body": [
      "#include \"bits/stdc++.h\"",
      "using namespace std;",
      "",
      "/*#define DEBUG 1",
      "",
      "#if DEBUG",
      "#define del cerr << '\\n'",
      "#define debug(...) _debug(#__VA_ARGS__, __VA_ARGS__)",
      "template <class X, class Y>",
      "ostream& operator<<(ostream& os, pair<X, Y> const& p) {",
      "    return os << \"(\" << p.first << \", \" << p.second << \")\";",
      "}",
      "template <class Ch, class Tr, class Container>",
      "basic_ostream<Ch, Tr>& operator<<(basic_ostream<Ch, Tr>& os, Container const& x) {",
      "    int i = 0, n = distance(x.begin(), x.end());",
      "    os << \"{ \";",
      "    for (const auto& y : x) os << y << (++i < n ? \", \" : \"\");",
      "    return os << \" }\";",
      "}",
      "template <typename... Args>",
      "void _debug(const char* names, Args&&... args) {",
      "    string_view s(names);",
      "    cerr << \"{ \";",
      "    size_t i = 0, cnt = 0, n = sizeof...(args);",
      "    auto next = [&]() {",
      "        while (i < s.size() && (s[i] == ' ' || s[i] == ',')) ++i;",
      "        size_t st = i;",
      "        while (i < s.size() && s[i] != ',') ++i;",
      "        return s.substr(st, i - st);",
      "    };",
      "    ((cerr << next() << \": \" << args << (++cnt < n ? \", \" : \"\")), ...);",
      "    cerr << \" }\" << '\\n';",
      "}",
      "#else",
      "#define del",
      "#define debug(...)",
      "#endif*/",
      "",
      "#define ll long long",
      "#define nl endl",
      "#define double long double",
      "#define pb push_back",
      "#define forn(i,a,n) for(int i=a;i<n;++i)",
      "#define all(a) a.begin(),a.end()",
      "#define getunique(v) {sort(all(v)); v.erase(unique(all(v)), v.end());}",
      "#define MOD(a,b) ((a%b)+b)%b",
      "#define vi vector<int>",
      "#define vb vector<bool>",
      "#define vvi vector<vector<int>>",
      "#define vd vector<double>",
      "#define vs vector<string>",
      "#define vll vector<ll>",
      "template<typename T>",
      "using min_heap = priority_queue<T, vector<T>, greater<T>>;",
      "#define fastnuces ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);int t = 1;",
      "#define yesno(b) cout << ((b)? \"YES\\n\" : \"NO\\n\")",
      "",
      "void solve(){$1",
      "",
      "}",
      "int32_t main() {",
      "    fastnuces;",
      "    cin >> t;",
      "    while (t--) {",
      "        solve();",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": ""
  },
  "runlengthencoding": {
    "prefix": "rle",
    "body": [
      "vector<pair<char,int>> run_length(const string &s) {",
      "    vector<pair<char,int>> rle;",
      "    int n = s.size();",
      "    for (int i = 0; i < n; ) {",
      "        int j = i;",
      "        while (j < n && s[j] == s[i]) j++;",
      "        rle.emplace_back(s[i], j - i);",
      "        i = j;",
      "    }",
      "    return rle;",
      "}"
    ],
    "description": ""
  },
  "binary trie": {
    "prefix": "binaryTrie",
    "body": [
      "struct Trie {",
      "    struct Node {",
      "        int nxt[2];",
      "        int cnt;",
      "        Node() : nxt{-1, -1}, cnt(0) {}",
      "    };",
      " ",
      "    vector<Node> t;",
      "    Trie() { t.emplace_back(); }",
      " ",
      "    void add(int x) {",
      "        int v = 0;",
      "        for (int b = 18; b >= 0; b--) {",
      "            int bit = (x >> b) & 1;",
      "            if (t[v].nxt[bit] == -1) {",
      "                t[v].nxt[bit] = t.size();",
      "                t.emplace_back();",
      "            }",
      "            v = t[v].nxt[bit];",
      "            t[v].cnt++;",
      "        }",
      "    }",
      " ",
      "    void del(int x) {",
      "        int v = 0;",
      "        for (int b = 18; b >= 0; b--) {",
      "            int bit = (x >> b) & 1;",
      "            v = t[v].nxt[bit];",
      "            t[v].cnt--;",
      "        }",
      "    }",
      " ",
      "    int max_xor(int x) {",
      "        int v = 0, res = 0;",
      "        for (int b = 18; b >= 0; b--) {",
      "            int bit = (x >> b) & 1;",
      "            int want = bit ^ 1;",
      "            if (t[v].nxt[want] != -1 &&",
      "                t[t[v].nxt[want]].cnt > 0) {",
      "                res |= (1 << b);",
      "                v = t[v].nxt[want];",
      "            } else {",
      "                v = t[v].nxt[bit];",
      "            }",
      "        }",
      "        return res;",
      "    }",
      "};"
    ],
    "description": ""
  },
  "LazySeg": {
    "prefix": "lazy",
    "body": [
      "const int inf = 1e18+5;",
      "",
      "template<class Info, class Tag>",
      "struct LazySegmentTree {",
      "    int n;",
      "    std::vector<Info> info;",
      "    std::vector<Tag> tag;",
      "    LazySegmentTree() : n(0) {}",
      "    LazySegmentTree(int n_, Info v_ = Info()) {",
      "        init(n_, v_);",
      "    }",
      "    template<class T>",
      "    LazySegmentTree(std::vector<T> init_) {",
      "        init(init_);",
      "    }",
      "    void init(int n_, Info v_ = Info()) {",
      "        init(std::vector(n_, v_));",
      "    }",
      "    template<class T>",
      "    void init(std::vector<T> init_) {",
      "        n = init_.size();",
      "        info.assign(4 << std::__lg(n), Info());",
      "        tag.assign(4 << std::__lg(n), Tag());",
      "        std::function<void(int, int, int)> build = [&](int p, int l, int r) {",
      "            if (r - l == 1) {",
      "                info[p] = init_[l];",
      "                return;",
      "            }",
      "            int m = (l + r) / 2;",
      "            build(2 * p, l, m);",
      "            build(2 * p + 1, m, r);",
      "            pull(p);",
      "        };",
      "        build(1, 0, n);",
      "    }",
      "    void pull(int p) {",
      "        info[p] = info[2 * p] + info[2 * p + 1];",
      "    }",
      "    void apply(int p, const Tag &v) {",
      "        info[p].apply(v);",
      "        tag[p].apply(v);",
      "    }",
      "    void push(int p) {",
      "        apply(2 * p, tag[p]);",
      "        apply(2 * p + 1, tag[p]);",
      "        tag[p] = Tag();",
      "    }",
      "    void modify(int p, int l, int r, int x, const Info &v) {",
      "        if (r - l == 1) {",
      "            info[p] = v;",
      "            return;",
      "        }",
      "        int m = (l + r) / 2;",
      "        push(p);",
      "        if (x < m) {",
      "            modify(2 * p, l, m, x, v);",
      "        } else {",
      "            modify(2 * p + 1, m, r, x, v);",
      "        }",
      "        pull(p);",
      "    }",
      "    void modify(int p, const Info &v) {",
      "        modify(1, 0, n, p, v);",
      "    }",
      "    Info rangeQuery(int p, int l, int r, int x, int y) {",
      "        if (l >= y || r <= x) {",
      "            return Info();",
      "        }",
      "        if (l >= x && r <= y) {",
      "            return info[p];",
      "        }",
      "        int m = (l + r) / 2;",
      "        push(p);",
      "        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);",
      "    }",
      "    Info rangeQuery(int l, int r) {",
      "        return rangeQuery(1, 0, n, l, r);",
      "    }",
      "    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {",
      "        if (l >= y || r <= x) {",
      "            return;",
      "        }",
      "        if (l >= x && r <= y) {",
      "            apply(p, v);",
      "            return;",
      "        }",
      "        int m = (l + r) / 2;",
      "        push(p);",
      "        rangeApply(2 * p, l, m, x, y, v);",
      "        rangeApply(2 * p + 1, m, r, x, y, v);",
      "        pull(p);",
      "    }",
      "    void rangeApply(int l, int r, const Tag &v) {",
      "        return rangeApply(1, 0, n, l, r, v);",
      "    }",
      "    void half(int p, int l, int r) {",
      "        if (info[p].act == 0) {",
      "            return;",
      "        }",
      "        if ((info[p].min + 1) / 2 == (info[p].max + 1) / 2) {",
      "            apply(p, {-(info[p].min + 1) / 2});",
      "            return;",
      "        }",
      "        int m = (l + r) / 2;",
      "        push(p);",
      "        half(2 * p, l, m);",
      "        half(2 * p + 1, m, r);",
      "        pull(p);",
      "    }",
      "    void half() {",
      "        half(1, 0, n);",
      "    }",
      "    ",
      "    template<class F>",
      "    int findFirst(int p, int l, int r, int x, int y, F &&pred) {",
      "        if (l >= y || r <= x) {",
      "            return -1;",
      "        }",
      "        if (l >= x && r <= y && !pred(info[p])) {",
      "            return -1;",
      "        }",
      "        if (r - l == 1) {",
      "            return l;",
      "        }",
      "        int m = (l + r) / 2;",
      "        push(p);",
      "        int res = findFirst(2 * p, l, m, x, y, pred);",
      "        if (res == -1) {",
      "            res = findFirst(2 * p + 1, m, r, x, y, pred);",
      "        }",
      "        return res;",
      "    }",
      "    template<class F>",
      "    int findFirst(int l, int r, F &&pred) {",
      "        return findFirst(1, 0, n, l, r, pred);",
      "    }",
      "    template<class F>",
      "    int findLast(int p, int l, int r, int x, int y, F &&pred) {",
      "        if (l >= y || r <= x) {",
      "            return -1;",
      "        }",
      "        if (l >= x && r <= y && !pred(info[p])) {",
      "            return -1;",
      "        }",
      "        if (r - l == 1) {",
      "            return l;",
      "        }",
      "        int m = (l + r) / 2;",
      "        push(p);",
      "        int res = findLast(2 * p + 1, m, r, x, y, pred);",
      "        if (res == -1) {",
      "            res = findLast(2 * p, l, m, x, y, pred);",
      "        }",
      "        return res;",
      "    }",
      "    template<class F>",
      "    int findLast(int l, int r, F &&pred) {",
      "        return findLast(1, 0, n, l, r, pred);",
      "    }",
      "    ",
      "    void maintainL(int p, int l, int r, int pre) {",
      "        if (info[p].difl > 0 && info[p].maxlowl < pre) {",
      "            return;",
      "        }",
      "        if (r - l == 1) {",
      "            info[p].max = info[p].maxlowl;",
      "            info[p].maxl = info[p].maxr = l;",
      "            info[p].maxlowl = info[p].maxlowr = -inf;",
      "            return;",
      "        }",
      "        int m = (l + r) / 2;",
      "        push(p);",
      "        maintainL(2 * p, l, m, pre);",
      "        pre = std::max(pre, info[2 * p].max);",
      "        maintainL(2 * p + 1, m, r, pre);",
      "        pull(p);",
      "    }",
      "    void maintainL() {",
      "        maintainL(1, 0, n, -1);",
      "    }",
      "    void maintainR(int p, int l, int r, int suf) {",
      "        if (info[p].difr > 0 && info[p].maxlowr < suf) {",
      "            return;",
      "        }",
      "        if (r - l == 1) {",
      "            info[p].max = info[p].maxlowl;",
      "            info[p].maxl = info[p].maxr = l;",
      "            info[p].maxlowl = info[p].maxlowr = -inf;",
      "            return;",
      "        }",
      "        int m = (l + r) / 2;",
      "        push(p);",
      "        maintainR(2 * p + 1, m, r, suf);",
      "        suf = std::max(suf, info[2 * p + 1].max);",
      "        maintainR(2 * p, l, m, suf);",
      "        pull(p);",
      "    }",
      "    void maintainR() {",
      "        maintainR(1, 0, n, -1);",
      "    }",
      "};",
      "",
      "struct Tag {",
      "    int x = 0;",
      "    void apply(const Tag &t) & {",
      "        x += t.x;",
      "    }",
      "};",
      "",
      "struct Info {",
      "    int x = 0;",
      "    Info(int val = 0) : x(val) {}",
      "    void apply(const Tag &t) & {",
      "        x += t.x;",
      "    }",
      "};",
      "",
      "Info operator+(const Info &a, const Info &b) {",
      "    return {a.x+b.x};",
      "}"
    ],
    "description": ""
  },
  "mint": {
    "prefix": "mint",
    "body": [
      "const int mod = 1e9 + 7;",
      "",
      "template <const int32_t MOD>",
      "struct modint {",
      "  int32_t value;",
      "  modint() = default;",
      "  modint(int32_t value_) : value(value_) {} // make sure value is less than MOD",
      "  inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.value; return modint<MOD>(c >= MOD ? c - MOD : c); }",
      "  inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.value; return modint<MOD>(c <    0 ? c + MOD : c); }",
      "  inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * other.value % MOD; return modint<MOD>(c < 0 ? c + MOD : c); }",
      "  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }",
      "  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }",
      "  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * other.value % MOD; if (this->value < 0) this->value += MOD; return *this; }",
      "  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : 0); }",
      "  modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k & 1) y *= x; x *= x; } return y; }",
      "  modint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime",
      "  inline modint<MOD> operator /  (modint<MOD> other) const { return *this *  other.inv(); }",
      "  inline modint<MOD> operator /= (modint<MOD> other)       { return *this *= other.inv(); }",
      "  inline bool operator == (modint<MOD> other) const { return value == other.value; }",
      "  inline bool operator != (modint<MOD> other) const { return value != other.value; }",
      "  inline bool operator < (modint<MOD> other) const { return value < other.value; }",
      "  inline bool operator > (modint<MOD> other) const { return value > other.value; }",
      "};",
      "template <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD>(value) * n; }",
      "template <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD>(value % MOD) * n; }",
      "template <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.value; }",
      "template <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.value; }",
      "",
      "using mint = modint<mod>;",
      ""
    ],
    "description": ""
  },
  "LowestCommonAncestor": {
    "prefix": "lca",
    "body": [
      "struct LowestCommon",
      "{",
      "    int n, LG;",
      "    vector<vector<int>> g;",
      "    vector<int> dep, sz;",
      "    vector<vector<int>> par;",
      "    LowestCommon(const vector<vector<int>> &adj)",
      "    {",
      "        n = adj.size();",
      "        LG = 20;",
      "        g = adj;",
      "        dep.resize(n);",
      "        sz.resize(n);",
      "        par.assign(n, vector<int>(LG + 1, 0));",
      "    }",
      "    void dfs(int u, int p = 0)",
      "    {",
      "        par[u][0] = p;",
      "        dep[u] = dep[p] + 1;",
      "        sz[u] = 1;",
      "        for (int i = 1; i <= LG; i++)",
      "            par[u][i] = par[par[u][i - 1]][i - 1];",
      "        for (auto v : g[u])",
      "            if (v != p)",
      "            {",
      "                dfs(v, u);",
      "                sz[u] += sz[v];",
      "            }",
      "    }",
      "    int lca(int u, int v)",
      "    {",
      "        if (dep[u] < dep[v])",
      "            swap(u, v);",
      "        for (int k = LG; k >= 0; k--)",
      "            if (dep[par[u][k]] >= dep[v])",
      "                u = par[u][k];",
      "        if (u == v)",
      "            return u;",
      "        for (int k = LG; k >= 0; k--)",
      "            if (par[u][k] != par[v][k])",
      "                u = par[u][k], v = par[v][k];",
      "        return par[u][0];",
      "    }",
      "    int kth(int u, int k)",
      "    {",
      "        assert(k >= 0);",
      "        for (int i = 0; i <= LG; i++)",
      "            if (k & (1 << i))",
      "                u = par[u][i];",
      "        return u;",
      "    }",
      "    int dist(int u, int v)",
      "    {",
      "        int l = lca(u, v);",
      "        return dep[u] + dep[v] - (dep[l] << 1);",
      "    }",
      "    int go(int u, int v, int k)",
      "    {",
      "        int l = lca(u, v);",
      "        int d = dep[u] + dep[v] - (dep[l] << 1);",
      "        assert(k <= d);",
      "        if (dep[l] + k <= dep[u])",
      "            return kth(u, k);",
      "        k -= dep[u] - dep[l];",
      "        return kth(v, dep[v] - dep[l] - k);",
      "    }",
      "};"
    ],
    "description": ""
  },
  "Fenwick": {
    "prefix": "bit",
    "body": [
      "/* MODIFICATION GUIDE:",
      " * 1. RANGE UPDATE / POINT QUERY:",
      " *    - Use this BIT as a difference array.",
      " *    - Range Add [l, r] with v: add(l, v), add(r+1, -v).",
      " *    - Point Query i: sum(i).",
      " * ",
      " * 2. RANGE UPDATE / RANGE QUERY:",
      " *    - Requires two BITs (BIT1, BIT2).",
      " *    - Update [l, r] with v:",
      " *      - BIT1.add(l, v), BIT1.add(r+1, -v)",
      " *      - BIT2.add(l, v*(l-1)), BIT2.add(r+1, -v*r)",
      " *    - Prefix Sum k: BIT1.sum(k) * k - BIT2.sum(k).",
      " */",
      "",
      "template <class T> struct BIT {",
    "	int n;",
    "	vector<T> b, a;",
    "	BIT(int n) : n(n), b(n+1), a(n) {}",
    "	BIT(vector<T>& v) : BIT(v.size()) {",
    "		for (int i = 0; i < n; ++i) add(i, v[i]);",
    "	}",
    "	void add(int i, T v) {",
    "		a[i] += v;",
    "		for (++i; i <= n; i += i & -i) b[i] += v;",
    "	}",
    "	void set(int i, T v) { add(i, v - a[i]); }",
    "	T sum(int i) {",
    "		T r = 0;",
    "		for (++i; i; i -= i & -i) r += b[i];",
    "		return r;",
    "	}",
    "	T sum(int l, int r) { return sum(r) - (l ? sum(l - 1) : 0); }",
    "	int lower_bound(T x) {",
    "		int i = 0;",
    "		for (int k = 1 << __lg(n); k; k >>= 1)",
    "			if (i + k <= n && b[i + k] < x)",
    "				x -= b[i += k];",
    "		return i;",
    "	}",
      "};",
      "",
      "/*",
      " * Usage:",
      " * BIT<int> bit(n); // Creates a BIT of size n (0-indexed internally, but usually used 0 to n-1)",
      " * bit.add(i, val); // Adds val to element at index i",
      " * bit.sum(i);      // Returns sum from index 0 to i",
      " * bit.sum(l, r);   // Returns sum from index l to r",
      " * bit.set(i, val); // Sets element at index i to val",
      " *",
      " * Example:",
      " * vector<int> v = {1, 2, 3, 4, 5};",
      " * BIT<int> bit(v);",
      " * cout << bit.sum(2) << endl; // Output: 6 (1+2+3)",
      " * cout << bit.sum(1, 3) << endl; // Output: 9 (2+3+4)",
      " * bit.add(2, 10); // v becomes {1, 2, 13, 4, 5}",
      " * cout << bit.sum(2) << endl; // Output: 16",
      " */"
    ],
    "description": "Fenwick"
  },
  "debug": {
    "prefix": "debug",
    "body": [
      "#ifndef DEBUG_TEMPLATE_CPP",
      "#define DEBUG_TEMPLATE_CPP",
      "#include <bits/stdc++.h>",
      "// #define cerr cout // <--- REMOVED THIS LINE so it uses actual cerr",
      "",
      "namespace __DEBUG_UTIL__",
      "{",
      "    using namespace std;",
      "",
      "    // SFINAE helpers for C++17 to detect iterables",
      "    template <typename T, typename = void>",
      "    struct is_iterable : false_type",
      "    {",
      "    };",
      "    template <typename T>",
      "    struct is_iterable<T, void_t<decltype(begin(declval<T>())), decltype(end(declval<T>()))>> : true_type",
      "    {",
      "    };",
      "    template <typename T>",
      "    constexpr bool is_iterable_v = is_iterable<T>::value;",
      "",
      "    template <typename T>",
      "    struct is_string : false_type",
      "    {",
      "    };",
      "    template <>",
      "    struct is_string<string> : true_type",
      "    {",
      "    };",
      "    template <typename T>",
      "    constexpr bool is_string_v = is_string<T>::value;",
      "",
      "    // Helper to detect std::pair",
      "    template <typename T>",
      "    struct is_pair : false_type",
      "    {",
      "    };",
      "    template <typename T, typename U>",
      "    struct is_pair<pair<T, U>> : true_type",
      "    {",
      "    };",
      "    template <typename T>",
      "    constexpr bool is_pair_v = is_pair<T>::value;",
      "",
      "    // SFINAE helpers for C++17 to detect .pop(), .top(), .front()",
      "    template <typename T, typename = void>",
      "    struct has_pop : false_type",
      "    {",
      "    };",
      "    template <typename T>",
      "    struct has_pop<T, void_t<decltype(declval<T>().pop())>> : true_type",
      "    {",
      "    };",
      "",
      "    template <typename T, typename = void>",
      "    struct has_top : false_type",
      "    {",
      "    };",
      "    template <typename T>",
      "    struct has_top<T, void_t<decltype(declval<T>().top())>> : true_type",
      "    {",
      "    };",
      "",
      "    template <typename T, typename = void>",
      "    struct has_front : false_type",
      "    {",
      "    };",
      "    template <typename T>",
      "    struct has_front<T, void_t<decltype(declval<T>().front())>> : true_type",
      "    {",
      "    };",
      "",
      "    // Base print functions",
      "    void print(const char *x) { cerr << x; }",
      "    void print(char x) { cerr << \"\\'\" << x << \"\\'\"; }",
      "    void print(bool x) { cerr << (x ? \"T\" : \"F\"); }",
      "    void print(string x) { cerr << \"\\\"\" << x << \"\\\"\"; }",
      "    void print(vector<bool> &v)",
      "    {",
      "        int f = 0;",
      "        cerr << '{';",
      "        for (auto &&i : v)",
      "            cerr << (f++ ? \",\" : \"\") << (i ? \"T\" : \"F\");",
      "        cerr << \"}\";",
      "    }",
      "",
      "    // Generic print",
      "    template <typename T>",
      "    void print(T &&x)",
      "    {",
      "        if constexpr (is_string_v<remove_cv_t<remove_reference_t<T>>>)",
      "        {",
      "            cerr << \"\\\"\" << x << \"\\\"\";",
      "        }",
      "        else if constexpr (is_pair_v<remove_cv_t<remove_reference_t<T>>>)",
      "        { // Correct Pair Check",
      "            cerr << '(', print(x.first), cerr << ',', print(x.second), cerr << ')';",
      "        }",
      "        else if constexpr (is_iterable_v<remove_cv_t<remove_reference_t<T>>>)",
      "        {",
      "            if (size(x) == 0)",
      "            {",
      "                cerr << \"{}\";",
      "                return;",
      "            }",
      "            if constexpr (is_iterable_v<decltype(*begin(x))>)",
      "            { // Iterable inside Iterable",
      "                int f = 0;",
      "                cerr << \"\\n~~~~~\\n\";",
      "                for (auto &&i : x)",
      "                {",
      "                    cerr << setw(2) << left << f++, print(i), cerr << \"\\n\";",
      "                }",
      "                cerr << \"~~~~~\\n\";",
      "            }",
      "            else",
      "            { // Normal Iterable",
      "                int f = 0;",
      "                cerr << \"{\";",
      "                for (auto &&i : x)",
      "                    cerr << (f++ ? \",\" : \"\"), print(i);",
      "                cerr << \"}\";",
      "            }",
      "        }",
      "        else if constexpr (has_pop<remove_cv_t<remove_reference_t<T>>>::value)",
      "        { // Stacks/Queues",
      "            auto temp = x;",
      "            int f = 0;",
      "            cerr << \"{\";",
      "            if constexpr (has_top<remove_cv_t<remove_reference_t<T>>>::value)",
      "                while (!temp.empty())",
      "                {",
      "                    cerr << (f++ ? \",\" : \"\");",
      "                    print(temp.top());",
      "                    temp.pop();",
      "                }",
      "            else",
      "                while (!temp.empty())",
      "                {",
      "                    cerr << (f++ ? \",\" : \"\");",
      "                    print(temp.front());",
      "                    temp.pop();",
      "                }",
      "            cerr << \"}\";",
      "        }",
      "        else // Fallback for single numbers",
      "            cerr << x;",
      "    }",
      "",
      "    template <typename T, typename... V>",
      "    void printer(const char *names, T &&head, V &&...tail)",
      "    {",
      "        int i = 0;",
      "        for (size_t bracket = 0; names[i] != '\\0' and (names[i] != ',' or bracket != 0); i++)",
      "            if (names[i] == '(' or names[i] == '<' or names[i] == '{')",
      "                bracket++;",
      "            else if (names[i] == ')' or names[i] == '>' or names[i] == '}')",
      "                bracket--;",
      "        cerr.write(names, i) << \" = \";",
      "        print(head);",
      "        if constexpr (sizeof...(tail))",
      "            cerr << \" ||\", printer(names + i + 1, tail...);",
      "        else",
      "            cerr << \"]\\n\";",
      "    }",
      "}",
      "",
      "// Ensure debug logic is enabled if ONPC is present",
      "#ifdef ONPC",
      "#define debug(...) std::cerr << __LINE__ << \": [\", __DEBUG_UTIL__::printer(#__VA_ARGS__, __VA_ARGS__)",
      "#else",
      "#define debug(...)",
      "#endif",
      "#endif"
    ],
    "description": "debug"
  },
  "templates": {
    "prefix": "templates",
    "body": [
      "DEBUG:",
      "#ifndef DEBUG_TEMPLATE_CPP",
      "#define DEBUG_TEMPLATE_CPP",
      "#include <bits/stdc++.h>",
      "namespace __DEBUG_UTIL__{using namespace std;",
      "template<class T,class=void>struct is_iterable:false_type{};",
      "template<class T>struct is_iterable<T,void_t<decltype(begin(declval<T>())),decltype(end(declval<T>()))>>:true_type{};",
      "template<class T>struct is_string:false_type{};template<>struct is_string<string>:true_type{};",
      "template<class T>struct is_pair:false_type{};template<class T,class U>struct is_pair<pair<T,U>>:true_type{};",
      "template<class T,class=void>struct has_pop:false_type{};template<class T>struct has_pop<T,void_t<decltype(declval<T>().pop())>>:true_type{};",
      "template<class T,class=void>struct has_top:false_type{};template<class T>struct has_top<T,void_t<decltype(declval<T>().top())>>:true_type{};",
      "template<class T,class=void>struct has_front:false_type{};template<class T>struct has_front<T,void_t<decltype(declval<T>().front())>>:true_type{};",
      "void print(const char*x){cerr<<x;}void print(char x){cerr<<\"'\"<<x<<\"'\";}void print(bool x){cerr<<(x?\"T\":\"F\");}void print(string x){cerr<<\"\\\"\"<<x<<\"\\\"\";}void print(vector<bool>&v){cerr<<\"{\";int f=0;for(auto&&i:v)cerr<<(f++?\",\":\"\")<<(i?\"T\":\"F\");cerr<<\"}\";}",
      "template<class T>void print(T&&x){",
      "if constexpr(is_string<decay_t<T>>::value)cerr<<\"\\\"\"<<x<<\"\\\"\";",
      "else if constexpr(is_pair<decay_t<T>>::value)cerr<<'(',print(x.first),cerr<<',',print(x.second),cerr<<')';",
      "else if constexpr(is_iterable<T>::value){if(size(x)==0){cerr<<\"{}\";return;}if constexpr(is_iterable<decltype(*begin(x))>::value){int f=0;cerr<<\"\\n~~~~~\\n\";for(auto&&i:x)cerr<<setw(2)<<left<<f++,print(i),cerr<<\"\\n\";cerr<<\"~~~~~\\n\";}else{int f=0;cerr<<\"{\";for(auto&&i:x)cerr<<(f++?\",\":\"\"),print(i);cerr<<\"}\";}}",
      "else if constexpr(has_pop<T>::value){auto t=x;int f=0;cerr<<\"{\";if constexpr(has_top<T>::value)while(!t.empty())cerr<<(f++?\",\":\"\"),print(t.top()),t.pop();else while(!t.empty())cerr<<(f++?\",\":\"\"),print(t.front()),t.pop();cerr<<\"}\";}",
      "else cerr<<x;}",
      "template<class T,class...V>void printer(const char*n,T&&h,V&&...t){int i=0;for(size_t b=0;n[i]&&(n[i]!=','||b);i++)if(n[i]=='('||n[i]=='<'||n[i]=='{')b++;else if(n[i]==')'||n[i]=='>'||n[i]=='}')b--;cerr.write(n,i)<<\" = \";print(h);if constexpr(sizeof...(t))cerr<<\" ||\",printer(n+i+1,t...);else cerr<<\"]\\n\";}}",
      "#ifdef ONPC",
      "#define debug(...) cerr<<__LINE__<<\": [\",__DEBUG_UTIL__::printer(#__VA_ARGS__,__VA_ARGS__)",
      "#else",
      "#define debug(...)",
      "#endif",
      "#endif",
      "",
      "Template:",
      "ME:",
      "#ifdef ONPC",
      "#define _GLIBCXX_DEBUG",
      "#endif#include <bits/stdc++.h>",
      "",
      "#ifdef ONPC#include \"debug.hpp\"",
      "",
      "#else",
      "#define debug(...) 42",
      "#endif",
      "using namespace std;",
      "",
      "void solve() {}",
      "",
      "int32_t main() {",
      "  ios::sync_with_stdio(0);",
      "  cin.tie(0);",
      "  int t = 1;",
      "  // cin >> t;",
      "  for (int i = 0; i < t; ++i) {",
      "    debug(t - i + 1);",
      "    solve();",
      "  }",
      "  return 0;",
      "}",
      "",
      "Bari:",
      "#include <bits/stdc++.h>",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "using namespace std;",
      "using namespace __gnu_pbds;",
      "template <typename T>",
      "using min_heap = priority_queue<T, vector<T>, greater<T>>;",
      "template <typename T>",
      "using max_heap = priority_queue<T>;",
      "template <typename T>",
      "using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
      "//find_by_order(k): returns iterator to k-th smallest element (0-based)",
      "//order_of_key(x): returns number of elements strictly less than x",
      "#define ll long long int",
      "#define ld long double",
      "#define nl cout<<\"\\n\"",
      "#define re return 0",
      "#define fs first",
      "#define sc second",
      "#define MOD 1000000007",
      "#define pii pair<ll,ll>",
      "#define vl vector<ll>",
      "#define vll vector<vector<ll>>",
      "#define vpii vector<pair<ll,ll>>",
      "#define vvpii vector<vector<pair<ll,ll>>>",
      "#define vb vector<bool>",
      "#define vbb vector<vector<bool>>",
      "#define vc vector<char>",
      "#define vcc vector<vector<char>>",
      "#define vs vector<string>",
      "#define vss vector<vector<string>>",
      "#define all(vec) vec.begin(), vec.end()",
      "#define allr(vec) vec.rbegin(), vec.rend()",
      "#define sahi(vec) sort(vec.begin(),vec.end())",
      "#define ulta(vec) sort(vec.begin(),vec.end(),greater<typename decltype(vec)::value_type>())",
      "#define fori(a,b) for(ll i=a;i<b;i++)",
      "#define forj(a,b) for(ll j=a;j<b;j++)",
      "#define fork(a,b) for(ll k=a;k<b;k++)",
      "#define forr(a,b) for(ll r=a;r>=b;r--)",
      "#define yes(expr) (expr)? cout<<\"yes\" : cout<<\"no\"",
      "#define Yes(expr) (expr)? cout<<\"Yes\" : cout<<\"No\"",
      "#define YES(expr) (expr)? cout<<\"YES\" : cout<<\"NO\"",
      "#define print(vec) for(auto x : vec) cout<<x<<\" \"",
      "#define io ios_base::sync_with_stdio(false);cin.tie(nullptr)",
      "",
      "template <typename A, typename B>",
      "istream& operator>>(istream &in, pair<A,B> &p) {",
      "    in >> p.first >> p.second;",
      "    return in;",
      "}",
      "template <typename T>",
      "istream& operator>>(istream &in, vector<T> &v) {",
      "    for (auto &x : v) in >> x;",
      "    return in;",
      "}",
      "",
      "template <typename A, typename B>",
      "ostream& operator<<(ostream &out, const pair<A,B> &p) {",
      "    out << p.first << \" \" << p.second;",
      "    return out;",
      "}",
      "template <typename T>",
      "ostream& operator<<(ostream &out, const vector<T> &v) {",
      "    for (auto &x : v) out << x << \" \";",
      "    return out;",
      "}",
      "",
      "int main()",
      "{",
      "    io;",
      "    ll t = 1;",
      "    cin>>t;",
      "    while(t--)",
      "    {",
      "        ",
      "    }",
      "    return 0;",
      "}",
      "",
      "DATA STRUCTS:",
      "",
      "LAZY:",
      "struct Node {",
      "    ll val = 0;",
      "",
      "    Node() {}",
      "    Node(ll v) : val(v) {}",
      "",
      "    // Change The Merge Function According to Segments Overlap Required",
      "    static Node merge(const Node &a, const Node &b) {",
      "        return Node(a.val + b.val);",
      "    }",
      "};",
      "",
      "class SegmentTree {",
      "    ll n;",
      "    vector<Node> tree;",
      "    vl arr, lazy;",
      "    vb has_lazy;",
      "",
      "public:",
      "    SegmentTree(const vl &input) {",
      "        arr = input;",
      "        n = arr.size();",
      "        tree.assign(4 * n, Node());",
      "        lazy.assign(4 * n, 0);",
      "        has_lazy.assign(4 * n, false);",
      "        build(1, 0, n - 1);",
      "    }",
      "",
      "private:",
      "    void build(ll idx, ll l, ll r) {",
      "        if (l == r) {",
      "            tree[idx] = Node(arr[l]);",
      "            return;",
      "        }",
      "        ll mid = (l + r) / 2;",
      "        build(2 * idx, l, mid);",
      "        build(2 * idx + 1, mid + 1, r);",
      "        tree[idx] = Node::merge(tree[2 * idx], tree[2 * idx + 1]);",
      "    }",
      "",
      "    void apply(ll idx, ll l, ll r, ll val) {",
      "        // ----- Set operation -----",
      "        tree[idx] = Node((r - l + 1) * val);",
      "        lazy[idx] = val;",
      "        has_lazy[idx] = true;",
      "",
      "        // ----- Add operation -----",
      "        // tree[idx].val += (r - l + 1) * val;",
      "        // lazy[idx] += val;",
      "        // has_lazy[idx] = true;",
      "    }",
      "",
      "    void push(ll idx, ll l, ll r) {",
      "        if (!has_lazy[idx] || l == r) return;",
      "        ll mid = (l + r) / 2;",
      "        apply(2 * idx, l, mid, lazy[idx]);",
      "        apply(2 * idx + 1, mid + 1, r, lazy[idx]);",
      "        lazy[idx] = 0;",
      "        has_lazy[idx] = false;",
      "    }",
      "",
      "    void update_range(ll ql, ll qr, ll val, ll idx, ll l, ll r) {",
      "        push(idx, l, r);",
      "        if (qr < l || r < ql) return;",
      "        if (ql <= l && r <= qr) {",
      "            apply(idx, l, r, val);",
      "            return;",
      "        }",
      "        ll mid = (l + r) / 2;",
      "        update_range(ql, qr, val, 2 * idx, l, mid);",
      "        update_range(ql, qr, val, 2 * idx + 1, mid + 1, r);",
      "        tree[idx] = Node::merge(tree[2 * idx], tree[2 * idx + 1]);",
      "    }",
      "",
      "    void update_point(ll pos, ll val, ll idx, ll l, ll r) {",
      "        push(idx, l, r);",
      "        if (l == r) {",
      "            tree[idx] = Node(val);",
      "            return;",
      "        }",
      "        ll mid = (l + r) / 2;",
      "        if (pos <= mid)",
      "            update_point(pos, val, 2 * idx, l, mid);",
      "        else",
      "            update_point(pos, val, 2 * idx + 1, mid + 1, r);",
      "        tree[idx] = Node::merge(tree[2 * idx], tree[2 * idx + 1]);",
      "    }",
      "",
      "    Node query(ll ql, ll qr, ll idx, ll l, ll r) {",
      "        push(idx, l, r);",
      "        if(qr < l || r < ql)",
      "            return Node();",
      "        if(ql <= l && r <= qr)",
      "            return tree[idx];",
      "        ll mid = (l + r) / 2;",
      "        return Node::merge(",
      "            query(ql, qr, 2 * idx, l, mid),",
      "            query(ql, qr, 2 * idx + 1, mid + 1, r)",
      "        );",
      "    }",
      "",
      "public:",
      "    // Public interfaces",
      "    void update(ll l, ll r, ll val) { update_range(l, r, val, 1, 0, n - 1); }     // range update",
      "    void update(ll pos, ll val) { update_point(pos, val, 1, 0, n - 1); }          // point update",
      "    ll query(ll l, ll r) { return query(l, r, 1, 0, n - 1).val; }",
      "};",
      "2D Prefix Sum:",
      "for (int i = 1; i <= n; i++) {",
      "  for (int j = 1; j <= m; j++) {",
      "    pref[i][j] = pref[i - 1][j] + pref[i][j - 1] - pref[i - 1][j - 1] + a[i][j];",
      "  }",
      "}",
      "pref[x2][y2] - pref[x1 - 1][y2] - pref[x2][y1 - 1] + pref[x1 - 1][y1 - 1] //( for query )",
      "",
      "",
      "BIT",
      "/* MODIFICATION GUIDE:",
      " * 1. RANGE UPDATE / POINT QUERY:",
      " *    - Use this BIT as a difference array.",
      " *    - Range Add [l, r] with v: add(l, v), add(r+1, -v).",
      " *    - Point Query i: sum(i).",
      " *",
      " * 2. RANGE UPDATE / RANGE QUERY:",
      " *    - Requires two BITs (BIT1, BIT2).",
      " *    - Update [l, r] with v:",
      " *      - BIT1.add(l, v), BIT1.add(r+1, -v)",
      " *      - BIT2.add(l, v*(l-1)), BIT2.add(r+1, -v*r)",
      " *    - Prefix Sum k: BIT1.sum(k) * k - BIT2.sum(k).",
      " */",
      "template < class T >",
      "  struct BIT {",
      "    int n;",
      "    vector < T > b, a;",
      "    BIT(int n): n(n), b(n + 1), a(n) {}",
      "    BIT(vector < T > & v): BIT(v.size()) {",
      "      for (int i = 0; i < n; ++i)",
      "        add(i, v[i]);",
      "    }",
      "    void add(int i, T v) {",
      "      a[i] += v;",
      "      for (++i; i <= n; i += i & -i)",
      "        b[i] += v;",
      "    }",
      "    void set(int i, T v) {",
      "      add(i, v - a[i]);",
      "    }",
      "    T sum(int i) {",
      "      T r = 0;",
      "      for (++i; i; i -= i & -i)",
      "        r += b[i];",
      "      return r;",
      "    }",
      "    T sum(int l, int r) {",
      "      return sum(r) - (l ? sum(l - 1) : 0);",
      "    }",
      "    int lower_bound(T x) {",
      "      int i = 0;",
      "      for (int k = 1 << __lg(n); k; k >>= 1)",
      "        if (i + k <= n && b[i + k] < x)",
      "          x -= b[i += k];",
      "      return i;",
      "    }",
      "  };",
      "/*",
      " * Usage:",
      " * BIT<int> bit(n); // Creates a BIT of size n (0-indexed internally, but usually used 0 to n-1)",
      " * bit.add(i, val); // Adds val to element at index i",
      " * bit.sum(i);      // Returns sum from index 0 to i",
      " * bit.sum(l, r);   // Returns sum from index l to r",
      " * bit.set(i, val); // Sets element at index i to val",
      " *",
      " * Example:",
      " * vector<int> v = {1, 2, 3, 4, 5};",
      " * BIT<int> bit(v);",
      " * cout << bit.sum(2) << endl; // Output: 6 (1+2+3)",
      " * cout << bit.sum(1, 3) << endl; // Output: 9 (2+3+4)",
      " * bit.add(2, 10); // v becomes {1, 2, 13, 4, 5}",
      " * cout << bit.sum(2) << endl; // Output: 16",
      " */",
      "",
      "",
      "/* MODIFICATION GUIDE:",
      " * 1. CHANGING DIMENSIONS:",
      " *    - Change template parameter N (e.g., Matrix<long long, 3>).",
      " *",
      " * 2. CHANGING TYPE:",
      " *    - Change template parameter T (e.g., Matrix<mint, 2>).",
      " *",
      " * 3. CUSTOM MODULO:",
      " *    - If T is 'long long' and you need modulo arithmetic, modify operator* to include % MOD.",
      " *    - Better to use 'mint' class as T.",
      " */",
      "",
      "template < class T, int N >",
      "  struct Matrix {",
      "    using M = Matrix;",
      "    array < array < T, N > , N > d {};",
      "    M operator * (const M & m) const {",
      "      M a;",
      "      for (int i = 0; i < N; ++i)",
      "        for (int k = 0; k < N; ++k)",
      "          for (int j = 0; j < N; ++j)",
      "            a.d[i][j] += d[i][k] * m.d[k][j];",
      "      return a;",
      "    }",
      "    array < T, N > operator * (const array < T, N > & v) const {",
      "      array < T, N > r {};",
      "      for (int i = 0; i < N; ++i)",
      "        for (int j = 0; j < N; ++j)",
      "          r[i] += d[i][j] * v[j];",
      "      return r;",
      "    }",
      "    M operator ^ (long long p) const {",
      "      assert(p >= 0);",
      "      M a, b = * this;",
      "      for (int i = 0; i < N; ++i)",
      "        a.d[i][i] = 1;",
      "      while (p) {",
      "        if (p & 1)",
      "          a = a * b;",
      "        b = b * b;",
      "        p >>= 1;",
      "      }",
      "      return a;",
      "    }",
      "  };",
      "",
      "/*",
      " * Usage:",
      " * Matrix<long long, 2> m; // 2x2 Matrix",
      " * m.d = {{{1, 1}, {1, 0}}}; // Fibonacci matrix",
      " * Matrix<long long, 2> res = m ^ 10; // Raise to power 10",
      " * cout << res.d[0][0] << endl; // Output: 89 (Fibonacci number)",
      " *",
      " * array<long long, 2> v = {1, 0};",
      " * array<long long, 2> v_res = res * v; // Multiply matrix by vector",
      " */",
      "ORDERED SET",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "using namespace __gnu_pbds;",
      "using namespace std;",
      "template < typename T >",
      "  using o_set = tree < T, null_type, less < T > , rb_tree_tag, tree_order_statistics_node_update > ;",
      "template < typename T, typename R >",
      "  using o_map = tree < T, R, less < T > , rb_tree_tag, tree_order_statistics_node_update > ;",
      "template < typename T >",
      "  using o_multiset = tree < T, null_type, less_equal < T > , rb_tree_tag, tree_order_statistics_node_update > ;",
      "",
      "",
      "template<class T> int sgn(T x) { return (x > 0) - (x < 0); }",
      "",
      "template<class T>",
      "struct Point {",
      "    typedef Point P; T x, y;",
      "    explicit Point(T x=0, T y=0) : x(x), y(y) {}",
      "    bool operator<(P p) const { return tie(x,y) < tie(p.x,p.y); }",
      "    bool operator==(P p) const { return tie(x,y) == tie(p.x,p.y); }",
      "    P operator+(P p) const { return P(x+p.x, y+p.y); }",
      "    P operator-(P p) const { return P(x-p.x, y-p.y); }",
      "    P operator*(T d) const { return P(x*d, y*d); }",
      "    P operator/(T d) const { return P(x/d, y/d); }",
      "    T dot(P p) const { return x*p.x + y*p.y; }",
      "    T cross(P p) const { return x*p.y - y*p.x; }",
      "    T cross(P a, P b) const { return (a-*this).cross(b-*this); }",
      "    T dist2() const { return x*x + y*y; }",
      "    double dist() const { return sqrt((double)dist2()); }",
      "    double angle() const { return atan2(y, x); }",
      "    P unit() const { return *this/dist(); }",
      "    P perp() const { return P(-y, x); }",
      "    P normal() const { return perp().unit(); }",
      "    P rotate(double a) const { return P(x*cos(a)-y*sin(a), x*sin(a)+y*cos(a)); }",
      "    friend ostream& operator<<(ostream& os, P p) { return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }",
      "};",
      "",
      "LAZY",
      "template <class I, class T>",
      "struct LazySegmentTree {",
      "    int n; std::vector<I> info; std::vector<T> tag;",
      "    LazySegmentTree(int n, I v = I()) { init(std::vector(n, v)); }",
      "    template <class V> LazySegmentTree(const V &v) { init(v); }",
      "    template <class V> void init(const V &v) {",
      "        n = v.size(); info.assign(4 * n, I()); tag.assign(4 * n, T());",
      "        std::function<void(int, int, int)> build = [&](int p, int l, int r) {",
      "            if (r - l == 1) { info[p] = v[l]; return; }",
      "            int m = (l + r) / 2; build(2 * p, l, m); build(2 * p + 1, m, r); pull(p);",
      "        };",
      "        build(1, 0, n);",
      "    }",
      "    void pull(int p) { info[p] = info[2 * p] + info[2 * p + 1]; }",
      "    void apply(int p, const T &v) { info[p].apply(v); tag[p].apply(v); }",
      "    void push(int p) { apply(2 * p, tag[p]); apply(2 * p + 1, tag[p]); tag[p] = T(); }",
      "    void modify(int p, int l, int r, int x, const I &v) {",
      "        if (r - l == 1) { info[p] = v; return; }",
      "        int m = (l + r) / 2; push(p);",
      "        if (x < m) modify(2 * p, l, m, x, v); else modify(2 * p + 1, m, r, x, v);",
      "        pull(p);",
      "    }",
      "    void modify(int p, const I &v) { modify(1, 0, n, p, v); }",
      "    I rangeQuery(int p, int l, int r, int x, int y) {",
      "        if (l >= y || r <= x) return I();",
      "        if (l >= x && r <= y) return info[p];",
      "        int m = (l + r) / 2; push(p);",
      "        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);",
      "    }",
      "    I rangeQuery(int l, int r) { return rangeQuery(1, 0, n, l, r); }",
      "    void rangeApply(int p, int l, int r, int x, int y, const T &v) {",
      "        if (l >= y || r <= x) return;",
      "        if (l >= x && r <= y) { apply(p, v); return; }",
      "        int m = (l + r) / 2; push(p);",
      "        rangeApply(2 * p, l, m, x, y, v); rangeApply(2 * p + 1, m, r, x, y, v); pull(p);",
      "    }",
      "    void rangeApply(int l, int r, const T &v) { rangeApply(1, 0, n, l, r, v); }",
      "};",
      "",
      "struct Tag { int x = 0; void apply(const Tag &t) { x += t.x; } };",
      "struct Info { int x = 0; Info(int v = 0) : x(v) {} void apply(const Tag &t) { x += t.x; } };",
      "Info operator+(const Info &a, const Info &b) { return {a.x + b.x}; }",
      "",
      "",
      "DP:",
      "LIS",
      "pair<ll,vl> lis(const vl &a) {",
      "    ll n = a.size();",
      "    vl d, idx(n), parent(n, -1);",
      "",
      "    fori(0,n)",
      "    {",
      "        auto it = lower_bound(d.begin(), d.end(), a[i]);",
      "        ll j = it - d.begin();",
      "",
      "        if(it == d.end())",
      "            d.push_back(a[i]);",
      "        else",
      "            *it = a[i];",
      "",
      "        idx[j] = i;",
      "        if(j > 0)",
      "            parent[i] = idx[j - 1];",
      "    }",
      "",
      "    // Reconstruct LIS",
      "    vl lis_seq;",
      "    for(ll i = idx[d.size() - 1]; i >= 0; i = parent[i])",
      "        lis_seq.push_back(a[i]);",
      "",
      "    reverse(all(lis_seq));",
      "    return {d.size(), lis_seq};",
      "}",
      "",
      "LCS",
      "pair<ll, string> lcs(const string &a, const string &b) {",
      "    ll n = a.size(), m = b.size();",
      "    vll dp(n+1,vl(m+1, 0));",
      "",
      "    // Build DP table",
      "    fori(1,n+1)",
      "    {",
      "        forj(1,m+1)",
      "        {",
      "            if(a[i-1] == b[j-1])",
      "                dp[i][j] = dp[i - 1][j - 1] + 1;",
      "            else",
      "                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);",
      "        }",
      "    }",
      "",
      "    // Reconstruct LCS string",
      "    string lcs_str;",
      "    ll i = n, j = m;",
      "    while(i > 0 && j > 0)",
      "    {",
      "        if (a[i - 1] == b[j - 1])",
      "        {",
      "            lcs_str.push_back(a[i - 1]);",
      "            i--;",
      "            j--;",
      "        }",
      "        else if(dp[i - 1][j] >= dp[i][j - 1])",
      "        {",
      "            i--;",
      "        }",
      "        else",
      "        {",
      "            j--;",
      "        }",
      "    }",
      "    reverse(all(lcs_str));",
      "",
      "    return {dp[n][m], lcs_str};",
      "}",
      "",
      "Graph : ",
      "",
      "Bridges",
      "class BridgeArticulationFinder {",
      "  int n;",
      "  int timer;",
      "  std::vector < std::vector < int >> adj;",
      "",
      "  std::vector < bool > visited;",
      "  std::vector < int > tin, low;",
      "  void run() {",
      "    timer = 0;",
      "    std::fill(visited.begin(), visited.end(), false);",
      "    std::fill(is_cutpoint.begin(), is_cutpoint.end(), false);",
      "    bridges.clear();",
      "",
      "    for (int i = 0; i < n; i++) {",
      "      if (!visited[i]) {",
      "        dfs(i);",
      "      }",
      "    }",
      "  }",
      "  void dfs(int u, int p = -1) {",
      "    visited[u] = true;",
      "    tin[u] = low[u] = timer++;",
      "    int children = 0;",
      "    bool parent_skipped = false;",
      "",
      "    for (int v: adj[u]) {",
      "",
      "      // skip exactly one edge to parent (important for multigraphs)",
      "      if (v == p && !parent_skipped) {",
      "        parent_skipped = true;",
      "        continue;",
      "      }",
      "",
      "      if (visited[v]) {",
      "        // back edge",
      "        low[u] = std::min(low[u], tin[v]);",
      "      } else {",
      "        dfs(v, u);",
      "        low[u] = std::min(low[u], low[v]);",
      "",
      "        // bridge condition",
      "        if (low[v] > tin[u]) {",
      "          bridges.emplace_back(min(v, u), max(v, u));",
      "        }",
      "",
      "        // articulation point (non-root)",
      "        if (low[v] >= tin[u] && p != -1) {",
      "          is_cutpoint[u] = true;",
      "        }",
      "",
      "        children++;",
      "      }",
      "    }",
      "",
      "    // articulation point (root)",
      "    if (p == -1 && children > 1) {",
      "      is_cutpoint[u] = true;",
      "    }",
      "  }",
      "",
      "  public:",
      "    std::vector < bool > is_cutpoint;",
      "  std::vector < std::pair < int, int >> bridges;",
      "",
      "  BridgeArticulationFinder(const std::vector < std::vector < int >> & adjacency): n(adjacency.size()), adj(adjacency) {",
      "    visited.assign(n, false);",
      "    tin.assign(n, -1);",
      "    low.assign(n, -1);",
      "    is_cutpoint.assign(n, false);",
      "    timer = 0;",
      "    run();",
      "  }",
      "};",
      "",
      "DSU",
      "// 1 indexed",
      "struct DSU {",
      "    std::vector<int> f, r, s; int c;",
      "    DSU(int n) : f(n+1), r(n+1), s(n+1, 1), c(n) { iota(f.begin(), f.end(), 0); }",
      "    int find(int i) { return f[i]==i ? i : f[i]=find(f[i]); }",
      "    bool same(int i, int j) { return find(i)==find(j); }",
      "    int get_size(int i) { return s[find(i)]; }",
      "    int count() { return c; }",
      "    int merge(int i, int j) {",
      "        if ((i=find(i)) == (j=find(j))) return -1;",
      "        c--;",
      "        if (r[i] > r[j]) std::swap(i, j);",
      "        f[i] = j; s[j] += s[i];",
      "        if (r[i] == r[j]) r[j]++;",
      "        return j;",
      "    }",
      "};",
      "",
      "LCA",
      "// 0 indexed",
      "struct LCA {",
      "    int n; std::vector<std::vector<int>> g, p; std::vector<int> d, sz;",
      "    LCA(std::vector<std::vector<int>> &adj) : n(adj.size()), g(adj), d(n), sz(n), p(n, std::vector<int>(20)) {}",
      "    void dfs(int u, int f) {",
      "        d[u] = d[f] + 1; p[u][0] = f; sz[u] = 1;",
      "        for (int i = 1; i < 20; i++) p[u][i] = p[p[u][i - 1]][i - 1];",
      "        for (int v : g[u]) if (v != f) dfs(v, u), sz[u] += sz[v];",
      "    }",
      "    void dfs(int u) { dfs(u, u); } ",
      "    int lca(int u, int v) {",
      "        if (d[u] < d[v]) std::swap(u, v);",
      "        for (int i = 19; i >= 0; i--) if (d[p[u][i]] >= d[v]) u = p[u][i];",
      "        if (u == v) return u;",
      "        for (int i = 19; i >= 0; i--) if (p[u][i] != p[v][i]) u = p[u][i], v = p[v][i];",
      "        return p[u][0];",
      "    }",
      "    int kth(int u, int k) {",
      "        for (int i = 0; i < 20; i++) if (k >> i & 1) u = p[u][i];",
      "        return u;",
      "    }",
      "    int dist(int u, int v) { return d[u] + d[v] - 2 * d[lca(u, v)]; }",
      "    int go(int u, int v, int k) {",
      "        int l = lca(u, v), D = d[u] + d[v] - 2 * d[l];",
      "        return k <= d[u] - d[l] ? kth(u, k) : kth(v, D - k);",
      "    }",
      "};",
      "",
      "Bellman Ford",
      "struct E { int u, v, w; };",
      "",
      "void solve() {",
      "    int n, m; cin >> n >> m;",
      "    vector<E> e(m);",
      "    for (auto &i : e) cin >> i.u >> i.v >> i.w, --i.u, --i.v;",
      "    ",
      "    vector<long long> d(n);",
      "    vector<int> p(n, -1);",
      "    int x;",
      "    ",
      "    for (int i = 0; i < n; ++i) {",
      "        x = -1;",
      "        for (auto &ed : e) {",
      "            if (d[ed.v] > d[ed.u] + ed.w) {",
      "                d[ed.v] = d[ed.u] + ed.w;",
      "                p[ed.v] = ed.u;",
      "                x = ed.v;",
      "            }",
      "        }",
      "    }",
      "    ",
      "    if (x == -1) { cout << \"NO\\n\"; return; }",
      "    ",
      "    for (int i = 0; i < n; ++i) x = p[x];",
      "    ",
      "    vector<int> path;",
      "    for (int v = x;; v = p[v]) {",
      "        path.push_back(v);",
      "        if (v == x && path.size() > 1) break;",
      "    }",
      "    reverse(path.begin(), path.end());",
      "    ",
      "    cout << \"YES\\n\";",
      "    for (int i : path) cout << i + 1 << ' ';",
      "}",
      "",
      "SCC",
      "class SCC{",
      "    vector<bool> vis;",
      "    vector<int> order;",
      "",
      "    void dfs1(int u) {",
      "        vis[u] = true;",
      "        for (int v : g[u])",
      "            if (!vis[v])",
      "                dfs1(v);",
      "        order.push_back(u);",
      "    }",
      "",
      "    void dfs2(int u, vector<int>& comp) {",
      "        vis[u] = true;",
      "        comp.push_back(u);",
      "        for (int v : rg[u])",
      "            if (!vis[v])",
      "                dfs2(v, comp);",
      "    }",
      "",
      "    void find_scc(int n) {",
      "        vis.assign(n, false);",
      "        order.clear();",
      "        for (int i = 0; i < n; ++i)",
      "            if (!vis[i])",
      "                dfs1(i);",
      "",
      "        vis.assign(n, false);",
      "        reverse(order.begin(), order.end());",
      "        scc.clear();",
      "        component_id.assign(n, -1); ",
      "        int id = 0; ",
      "        for (int u : order)",
      "            if (!vis[u]) {",
      "                vector<int> comp;",
      "                dfs2(u, comp);",
      "                for (int v : comp) {",
      "                    component_id[v] = id; ",
      "                }",
      "                scc.push_back(comp);",
      "                id++; ",
      "            }",
      "    }",
      "    void build_condened_graph(vector<pair<int,int>>& edges){",
      "        int k = scc.size();",
      "        dag.assign(k, {});",
      "        for(auto [u,v]: edges){",
      "            int cu = component_id[u];",
      "            int cv = component_id[v];",
      "            if(cu != cv){",
      "                dag[cu].push_back(cv);",
      "            }",
      "        }",
      "    }",
      "    public:",
      "    vector<int> component_id;",
      "    vector<vector<int>> dag;",
      "    vector<vector<int>> g, rg, scc;",
      "    SCC(int n, vector<pair<int,int>>& edges){",
      "        g.assign(n, {});",
      "        rg.assign(n, {});",
      "        for(auto& e: edges){",
      "            int u = e.first;",
      "            int v = e.second;",
      "            g[u].push_back(v);",
      "            rg[v].push_back(u);",
      "        }",
      "        find_scc(n);",
      "        build_condened_graph(edges);",
      "    }",
      "",
      "};",
      "",
      "BIPARTITE MATCHING:",
      "struct HopcroftKarp {",
      "    ll n, m;                // n = size of left set, m = size of right set",
      "    vll adj;                // adjacency list from left to right",
      "    vl dist, matchL, matchR;",
      "",
      "    HopcroftKarp(ll n, ll m) : n(n), m(m) {",
      "        adj.resize(n);",
      "        dist.resize(n);",
      "        matchL.assign(n, -1);",
      "        matchR.assign(m, -1);",
      "    }",
      "",
      "    void addEdge(ll u, ll v) {",
      "        adj[u].push_back(v);",
      "    }",
      "",
      "    bool bfs() {",
      "        queue<ll> q;",
      "        for (ll u = 0; u < n; u++) {",
      "            if (matchL[u] == -1) {",
      "                dist[u] = 0;",
      "                q.push(u);",
      "            } else {",
      "                dist[u] = INT_MAX;",
      "            }",
      "        }",
      "",
      "        bool found = false;",
      "",
      "        while (!q.empty()) {",
      "            ll u = q.front(); q.pop();",
      "            for (ll v : adj[u]) {",
      "                ll w = matchR[v];",
      "                if (w == -1) {",
      "                    found = true;",
      "                } else if (w != -1 && dist[w] == INT_MAX) {",
      "                    dist[w] = dist[u] + 1;",
      "                    q.push(w);",
      "                }",
      "            }",
      "        }",
      "        return found;",
      "    }",
      "",
      "    bool dfs(ll u) {",
      "        for (ll v : adj[u]) {",
      "            ll w = matchR[v];",
      "            if (w == -1 || (dist[w] == dist[u] + 1 && dfs(w))) {",
      "                matchL[u] = v;",
      "                matchR[v] = u;",
      "                return true;",
      "            }",
      "        }",
      "        dist[u] = INT_MAX;",
      "        return false;",
      "    }",
      "",
      "    ll maxMatching() {",
      "        ll matching = 0;",
      "        while (bfs()) {",
      "            for (ll u = 0; u < n; u++) {",
      "                if (matchL[u] == -1 && dfs(u))",
      "                    matching++;",
      "            }",
      "        }",
      "        return matching;",
      "    }",
      "};",
      "",
      "MAXFLOW:",
      "struct Edge {",
      "    ll to, rev;",
      "    ll cap, cost;",
      "    Edge(ll to, ll rev, ll cap, ll cost) : to(to), rev(rev), cap(cap), cost(cost) {}",
      "};",
      "",
      "struct MinCostMaxFlow {",
      "    ll n;",
      "    vector<vector<Edge>> adj;",
      "    vl dist, potential, parentNode, parentEdge;",
      "    const ll INF = 1e15;",
      "",
      "    MinCostMaxFlow(ll n) : n(n) {",
      "        adj.assign(n, vector<Edge>());",
      "        dist.assign(n, INF);",
      "        potential.assign(n, 0);",
      "        parentNode.assign(n, -1);",
      "        parentEdge.assign(n, -1);",
      "    }",
      "",
      "    void add_edge(ll u, ll v, ll cap, ll cost) {",
      "        adj[u].emplace_back(v, (ll)adj[v].size(), cap, cost);",
      "        adj[v].emplace_back(u, (ll)adj[u].size() - 1, 0, -cost);",
      "    }",
      "",
      "    bool bellman_ford(ll s) {",
      "        fill(potential.begin(), potential.end(), INF);",
      "        potential[s] = 0;",
      "        bool updated;",
      "        for (ll iter = 0; iter < n - 1; iter++) {",
      "            updated = false;",
      "            for (ll u = 0; u < n; u++) {",
      "                if (potential[u] == INF) continue;",
      "                for (auto &e : adj[u]) {",
      "                    if (e.cap > 0 && potential[u] + e.cost < potential[e.to]) {",
      "                        potential[e.to] = potential[u] + e.cost;",
      "                        updated = true;",
      "                    }",
      "                }",
      "            }",
      "            if (!updated) break;",
      "        }",
      "        // Optional: check for negative cycle here if needed.",
      "        return true;",
      "    }",
      "",
      "    bool dijkstra(ll s, ll t) {",
      "        fill(dist.begin(), dist.end(), INF);",
      "        dist[s] = 0;",
      "",
      "        using pli = pair<ll, ll>;",
      "        priority_queue<pli, vector<pli>, greater<pli>> pq;",
      "        pq.push({0, s});",
      "",
      "        while (!pq.empty()) {",
      "            auto [d, u] = pq.top(); pq.pop();",
      "            if (d != dist[u]) continue;",
      "            if (u == t) return true;",
      "",
      "            for (ll i = 0; i < (ll)adj[u].size(); i++) {",
      "                Edge &e = adj[u][i];",
      "                if (e.cap > 0) {",
      "                    ll cost_with_pot = e.cost + potential[u] - potential[e.to];",
      "                    if (dist[u] + cost_with_pot < dist[e.to]) {",
      "                        dist[e.to] = dist[u] + cost_with_pot;",
      "                        parentNode[e.to] = u;",
      "                        parentEdge[e.to] = i;",
      "                        pq.push({dist[e.to], e.to});",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        return false;",
      "    }",
      "",
      "    pii min_cost_max_flow(ll s, ll t) {",
      "        ll flow = 0, cost = 0;",
      "",
      "        // If Negative Costs Run Bellman-Ford once to properly Initialize Potentials for Dijkstra",
      "        // bellman_ford(s);",
      "",
      "        // If Positive Costs Initializing Potentials Zero for Dijkstra",
      "        fill(potential.begin(), potential.end(), 0);",
      "",
      "        while (dijkstra(s, t)) {",
      "            for (ll i = 0; i < n; i++) {",
      "                if (dist[i] < INF)",
      "                    potential[i] += dist[i];",
      "            }",
      "",
      "            ll pushed = LLONG_MAX;",
      "            for (ll v = t; v != s; v = parentNode[v]) {",
      "                ll u = parentNode[v];",
      "                ll idx = parentEdge[v];",
      "                pushed = min(pushed, adj[u][idx].cap);",
      "            }",
      "",
      "            for (ll v = t; v != s; v = parentNode[v]) {",
      "                ll u = parentNode[v];",
      "                ll idx = parentEdge[v];",
      "                adj[u][idx].cap -= pushed;",
      "                adj[v][adj[u][idx].rev].cap += pushed;",
      "                cost += pushed * adj[u][idx].cost;",
      "            }",
      "",
      "            flow += pushed;",
      "        }",
      "        return {flow, cost};",
      "    }",
      "};",
      "",
      "DINIC:",
      "struct Edge {",
      "    ll to, rev;",
      "    ll cap;",
      "    Edge(ll to, ll rev, ll cap) : to(to), rev(rev), cap(cap) {}",
      "};",
      "",
      "struct Dinic {",
      "    ll n;",
      "    vector<vector<Edge>> adj;",
      "    vl level, ptr;",
      "",
      "    Dinic(ll n) : n(n) {",
      "        adj.assign(n, vector<Edge>());",
      "        level.assign(n, -1);",
      "        ptr.assign(n, 0);",
      "    }",
      "",
      "    void add_edge(ll u, ll v, ll cap) {",
      "        adj[u].emplace_back(v, (ll)adj[v].size(), cap);",
      "        adj[v].emplace_back(u, (ll)adj[u].size() - 1, 0); // reverse edge",
      "    }",
      "",
      "    void print_all_edges() {",
      "        for (ll u = 0; u < n; u++) {",
      "            for (ll i = 0; i < (ll)adj[u].size(); i++) {",
      "                Edge &e = adj[u][i];",
      "",
      "                bool is_backward = false;",
      "                is_backward = (adj[e.to][e.rev].to == u) && (i % 2 == 1);",
      "",
      "                cout << \"Edge from \" << u << \" to \" << e.to ",
      "                    << \" | cap = \" << e.cap",
      "                    << \" | \" << (is_backward ? \"Backward edge\" : \"Forward edge\") << \"\\n\";",
      "            }",
      "        }",
      "    }",
      "",
      "    bool bfs(ll s, ll t) {",
      "        fill(level.begin(), level.end(), -1);",
      "        level[s] = 0;",
      "        queue<ll> q; q.push(s);",
      "        while (!q.empty()) {",
      "            ll u = q.front(); q.pop();",
      "            for (auto &e : adj[u]) {",
      "                if (e.cap > 0 && level[e.to] == -1) {",
      "                    level[e.to] = level[u] + 1;",
      "                    q.push(e.to);",
      "                }",
      "            }",
      "        }",
      "        return level[t] != -1;",
      "    }",
      "",
      "    ll dfs(ll u, ll t, ll flow) {",
      "        if (u == t || flow == 0) return flow;",
      "        for (ll &i = ptr[u]; i < (ll)adj[u].size(); i++) {",
      "            Edge &e = adj[u][i];",
      "            if (level[e.to] == level[u] + 1 && e.cap > 0) {",
      "                ll pushed = dfs(e.to, t, min(flow, e.cap));",
      "                if (pushed > 0) {",
      "                    e.cap -= pushed;",
      "                    adj[e.to][e.rev].cap += pushed;",
      "                    return pushed;",
      "                }",
      "            }",
      "        }",
      "        return 0;",
      "    }",
      "",
      "    ll max_flow(ll s, ll t) {",
      "        ll flow = 0;",
      "        while (bfs(s, t)) {",
      "            fill(ptr.begin(), ptr.end(), 0);",
      "            while (ll pushed = dfs(s, t, LLONG_MAX)) {",
      "                flow += pushed;",
      "            }",
      "        }",
      "        return flow;",
      "    }",
      "",
      "    vb min_cut_reachable(ll s) {",
      "        vb visited(n, false);",
      "        queue<ll> q; q.push(s);",
      "        visited[s] = true;",
      "        while (!q.empty()) {",
      "            ll u = q.front(); q.pop();",
      "            for (auto &e : adj[u]) {",
      "                if (e.cap > 0 && !visited[e.to]) {",
      "                    visited[e.to] = true;",
      "                    q.push(e.to);",
      "                }",
      "            }",
      "        }",
      "        return visited;",
      "    }",
      "",
      "    vpii get_min_cut_edges(ll s) {",
      "        vpii cut_edges;",
      "        vb visited = min_cut_reachable(s);",
      "",
      "        for (ll u = 0; u < n; u++) {",
      "            if (visited[u]) {",
      "                for (auto &e : adj[u]) {",
      "                    if (!visited[e.to] && e.cap == 0) {",
      "                        cut_edges.emplace_back(u, e.to);",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        return cut_edges;",
      "    }",
      "};",
      "",
      "Number Theory:",
      "long long binPow(long long a, long long b, long long m) {",
      "    long long r = 1; a %= m;",
      "    while (b) { if (b & 1) r = (__int128)r * a % m; a = (__int128)a * a % m; b >>= 1; }",
      "    return r;",
      "}",
      "",
      "",
      "Binomial Coef",
      "const ll MoD = 1e9+7;",
      "vl fact, invfact;",
      "",
      "ll modpow(ll a, ll b, ll m = MoD) {",
      "    ll res = 1;",
      "    while (b) {",
      "        if (b & 1)",
      "            res = (res * a) % m;",
      "        a = (a * a) % m;",
      "        b >>= 1;",
      "    }",
      "    return res;",
      "}",
      "",
      "void build_fact(ll n) {",
      "    fact.assign(n+1, 1);",
      "    invfact.assign(n+1, 1);",
      "",
      "    for (ll i = 1; i <= n; i++)",
      "        fact[i] = (fact[i-1] * i) % MoD;",
      "",
      "    invfact[n] = modpow(fact[n], MoD-2, MoD); // Fermat's inverse",
      "",
      "    for (ll i = n-1; i >= 0; i--)",
      "        invfact[i] = (invfact[i+1] * (i+1)) % MoD;",
      "}",
      "",
      "ll nCr(ll n, ll r) {",
      "    if (r < 0 || r > n) return 0;",
      "    return (((fact[n] * invfact[r]) % MoD) * invfact[n-r]) % MoD;",
      "}",
      "",
      "ll nPr(ll n, ll r) {",
      "    if (r < 0 || r > n) return 0;",
      "    return (fact[n] * invfact[n-r]) % MoD;",
      "}",
      "",
      "",
      "",
      "vector<long long> getDivs(long long n) {",
      "    vector<long long> d;",
      "    for (long long i = 1; i * i <= n; ++i) ",
      "        if (n % i == 0) { d.push_back(i); if (i * i != n) d.push_back(n / i); }",
      "    sort(d.begin(), d.end()); return d;",
      "}",
      "vector<long long> getPF(long long n) {",
      "    vector<long long> f;",
      "    for (long long i = 2; i * i <= n; i += 1 + (i % 2))",
      "        while (n % i == 0) f.push_back(i), n /= i;",
      "    if (n > 1) f.push_back(n);",
      "    return f;",
      "}",
      "",
      "template<int M> struct modint {",
      "    int v;",
      "    modint(long long x = 0) : v(x % M) { if (v < 0) v += M; }",
      "    modint& operator+=(const modint& o) { if ((v += o.v) >= M) v -= M; return *this; }",
      "    modint& operator-=(const modint& o) { if ((v -= o.v) < 0) v += M; return *this; }",
      "    modint& operator*=(const modint& o) { v = 1LL * v * o.v % M; return *this; }",
      "    modint& operator/=(const modint& o) { return *this *= o.inv(); }",
      "    modint operator-() const { return modint() - *this; }",
      "    modint pow(long long k) const {",
      "        modint r = 1, x = *this;",
      "        for (; k; k >>= 1) { if (k & 1) r *= x; x *= x; }",
      "        return r;",
      "    }",
      "    modint inv() const { return pow(M - 2); }",
      "    friend modint operator+(modint a, const modint& b) { return a += b; }",
      "    friend modint operator-(modint a, const modint& b) { return a -= b; }",
      "    friend modint operator*(modint a, const modint& b) { return a *= b; }",
      "    friend modint operator/(modint a, const modint& b) { return a /= b; }",
      "    friend bool operator==(const modint& a, const modint& b) { return a.v == b.v; }",
      "    friend bool operator!=(const modint& a, const modint& b) { return a.v != b.v; }",
      "    friend bool operator<(const modint& a, const modint& b) { return a.v < b.v; }",
      "    friend istream& operator>>(istream& i, modint& m) { long long x; i >> x; m = x; return i; }",
      "    friend ostream& operator<<(ostream& o, const modint& m) { return o << m.v; }",
      "};",
      "using mint = modint<mod>;",
      "",
      "const int N = 1e5 + 9;",
      "int spf[N]; vector<int> p;",
      "",
      "void sieve() {",
      "    for (int i = 2; i < N; i++) {",
      "        if (!spf[i]) spf[i] = i, p.push_back(i);",
      "        for (int j : p) {",
      "            if (i * j >= N || j > spf[i]) break;",
      "            spf[i * j] = j;",
      "        }",
      "    }",
      "}",
      "",
      "",
      "Strings:",
      "KMP:",
      "vl build_lps(const string &pat) {",
      "    ll m = pat.size();",
      "    vl lps(m, 0);",
      "",
      "    for (ll i = 1, len = 0; i < m; ) {",
      "        if (pat[i] == pat[len]) {",
      "            lps[i++] = ++len;",
      "        } else {",
      "            if (len != 0) {",
      "                len = lps[len - 1];",
      "            } else {",
      "                lps[i++] = 0;",
      "            }",
      "        }",
      "    }",
      "    return lps;",
      "}",
      "",
      "vl kmp(const string &text, const string &pat) {",
      "    ll n = text.size(), m = pat.size();",
      "    vl lps = build_lps(pat);",
      "    vl occurrences;",
      "",
      "    for (ll i = 0, j = 0; i < n; ) {",
      "        if (text[i] == pat[j]) {",
      "            i++; j++;",
      "        }",
      "",
      "        if (j == m) {",
      "            occurrences.push_back(i - j); // match found (0-based index)",
      "            j = lps[j - 1];",
      "        } else if (i < n && text[i] != pat[j]) {",
      "            if (j != 0)",
      "                j = lps[j - 1];",
      "            else",
      "                i++;",
      "        }",
      "    }",
      "    return occurrences;",
      "}",
      "HASHING",
      "using ull = unsigned long long;",
      "int gen_base(int l = 257) {",
      "    auto t = chrono::steady_clock::now().time_since_epoch().count();",
      "    mt19937_64 r(t); return (l + r() % (int)(1e9 - l)) | 1;",
      "}",
      "",
      "struct PolyHash {",
      "    static const int M = 1e9 + 7;",
      "    int n; vector<int> h, p; vector<ull> H, P;",
      "    PolyHash(string s, int b = 0) : n(s.size()) {",
      "        if (!b) b = gen_base();",
      "        h.resize(n + 1); p.assign(n + 1, 1);",
      "        H.resize(n + 1); P.assign(n + 1, 1);",
      "        for (int i = 0; i < n; ++i) {",
      "            h[i + 1] = (1LL * h[i] * b + (unsigned char)s[i]) % M;",
      "            p[i + 1] = 1LL * p[i] * b % M;",
      "            H[i + 1] = H[i] * b + (unsigned char)s[i];",
      "            P[i + 1] = P[i] * b;",
      "        }",
      "    }",
      "    // get hash of substring [l, l+len)",
      "    pair<int, ull> get(int l, int len) {",
      "        int r = l + len;",
      "        int v = (h[r] - 1LL * h[l] * p[len] % M + M) % M;",
      "        return {v, H[r] - H[l] * P[len]};",
      "    }",
      "    // get hash of string excluding range [L, R]",
      "    pair<int, ull> exclude(int L, int R) {",
      "        if (!n) return {0, 0};",
      "        L = max(0, L); R = min(n - 1, R);",
      "        if (L > R) return get(0, n);",
      "        auto x = get(0, L), y = get(R + 1, n - 1 - R);",
      "        int v = (1LL * x.first * p[n - 1 - R] + y.first) % M;",
      "        return {v, x.second * P[n - 1 - R] + y.second};",
      "    }",
      "};",
      "",
      "MANACHER",
      "// 0 is even, 1 is odd",
      "array<vector<int>, 2> manacher(const string &s) {",
      "    int n = s.size();",
      "    array<vector<int>, 2> p = {vector<int>(n + 1), vector<int>(n)};",
      "    for (int z = 0; z < 2; ++z)",
      "        for (int i = 0, l = 0, r = 0; i < n; i++) {",
      "            int t = r - i + !z;",
      "            if (i < r) p[z][i] = min(t, p[z][l + t]);",
      "            int L = i - p[z][i], R = i + p[z][i] - !z;",
      "            while (L >= 1 && R + 1 < n && s[L - 1] == s[R + 1]) p[z][i]++, L--, R++;",
      "            if (R > r) l = L, r = R;",
      "        }",
      "    return p;",
      "}",
      "",
      "String Matching FFT ",
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "using C = complex<double>;",
      "void fft(vector<C>& a, bool inv) {",
      "    int n = a.size();",
      "    for (int i = 1, j = 0; i < n; i++) {",
      "        int bit = n >> 1;",
      "        for (; j & bit; bit >>= 1) j ^= bit;",
      "        j ^= bit; if (i < j) swap(a[i], a[j]);",
      "    }",
      "    for (int len = 2; len <= n; len <<= 1) {",
      "        double ang = 2 * acos(-1) / len * (inv ? -1 : 1);",
      "        C wlen(cos(ang), sin(ang));",
      "        for (int i = 0; i < n; i += len) {",
      "            C w(1);",
      "            for (int j = 0; j < len / 2; j++) {",
      "                C u = a[i + j], v = a[i + j + len / 2] * w;",
      "                a[i + j] = u + v; a[i + j + len / 2] = u - v;",
      "                w *= wlen;",
      "            }",
      "        }",
      "    }",
      "    if (inv) for (auto& x : a) x /= n;",
      "}",
      "vector<int> mul(vector<int>& a, vector<int>& b) {",
      "    int n = 1; while (n < a.size() + b.size()) n <<= 1;",
      "    vector<C> fa(a.begin(), a.end()), fb(b.begin(), b.end());",
      "    fa.resize(n); fb.resize(n);",
      "    fft(fa, 0); fft(fb, 0);",
      "    for (int i = 0; i < n; i++) fa[i] *= fb[i];",
      "    fft(fa, 1);",
      "    vector<int> res(n);",
      "    for (int i = 0; i < n; i++) res[i] = round(fa[i].real());",
      "    return res;",
      "}",
      "vector<int> solve(string& s, string& t) {",
      "    int n = s.size(), m = t.size();",
      "    vector<int> s1(n), s2(n), s3(n), t1(m), t2(m), t3(m);",
      "    for (int i = 0; i < n; i++) { int v = (s[i] == '?' ? 0 : s[i] - 'a' + 1); s1[i] = v; s2[i] = v * v; s3[i] = v * v * v; }",
      "    for (int i = 0; i < m; i++) { int v = (t[i] == '?' ? 0 : t[i] - 'a' + 1); t1[i] = v; t2[i] = v * v; t3[i] = v * v * v; }",
      "    reverse(t1.begin(), t1.end()); reverse(t2.begin(), t2.end()); reverse(t3.begin(), t3.end());",
      "    auto r1 = mul(s1, t3), r2 = mul(s2, t2), r3 = mul(s3, t1);",
      "    vector<int> ans;",
      "    for (int i = m - 1; i < n; i++) if (r1[i] - 2 * r2[i] + r3[i] == 0) ans.push_back(i - m + 1);",
      "    return ans;",
      "}",
      "int main() {",
      "    ios::sync_with_stdio(0); cin.tie(0);",
      "    int t; cin >> t;",
      "    while (t--) {",
      "        string a, b; cin >> a >> b;",
      "        auto ans = solve(a, b);",
      "        if (ans.empty()) cout << \"Not Found\\n\";",
      "        else for (int x : ans) cout << x + 1 << \"\\n\";",
      "        if (t) cout << \"\\n\";",
      "    }",
      "}",
      "",
      "",
      "STL ROPES:",
      "#include <ext/rope>",
      "using namespace __gnu_cxx;",
      "using rp = rope<char>; ",
      "// Usage:",
      "// 1. Insert:  s.insert(pos, \"str\");   // O(log N)",
      "// 2. Erase:   s.erase(pos, len);      // O(log N)",
      "// 3. Substr:  s.substr(pos, len);     // O(log N) -> returns new rope",
      "// 4. Access:  s[i];                   // O(log N)",
      "// 5. Concat:  s += t;                 // O(1)",
      "// 6. Persist: rp s2 = s1;             // O(1)",
      "int main() {",
      "    rp s;",
      "    s += \"Hello\";              // s = \"Hello\"",
      "    s.insert(5, \" World\");     // s = \"Hello World\"",
      "    rp s2 = s;                 // s2 is a persistent copy of s (O(1))",
      "    s.erase(0, 6);             // s = \"World\" (s2 is still \"Hello World\")",
      "    cout << s << \" \" << s2;    // Output: World Hello World",
      "}",
      "",
      "TRIE",
      "struct Trie {",
      "    vector<vector<int>> t = {{-1, -1}}; vector<int> c = {0};",
      "    void add(int x) {",
      "        int v = 0;",
      "        for (int i = 32; i >= 0; i--) {",
      "            int b = x >> i & 1;",
      "            if (t[v][b] == -1) t[v][b] = t.size(), t.push_back({-1, -1}), c.push_back(0);",
      "            v = t[v][b]; c[v]++;",
      "        }",
      "    }",
      "    void del(int x) {",
      "        int v = 0;",
      "        for (int i = 32; i >= 0; i--) {",
      "            int b = x >> i & 1;",
      "            v = t[v][b]; c[v]--;",
      "        }",
      "    }",
      "    int max_xor(int x) {",
      "        int v = 0, r = 0;",
      "        for (int i = 32; i >= 0; i--) {",
      "            int b = (x >> i & 1) ^ 1;",
      "            if (t[v][b] != -1 && c[t[v][b]]) r |= 1 << i, v = t[v][b];",
      "            else v = t[v][b ^ 1];",
      "        }",
      "        return r;",
      "    }",
      "};",
      "",
      "STRING TRIE:",
      "",
      "struct TrieNode {",
      "    TrieNode* next[26];",
      "    bool isEnd;",
      "    int count;",
      "",
      "    TrieNode() {",
      "        for (int i = 0; i < 26; i++) next[i] = nullptr;",
      "        isEnd = false;",
      "        count = 0;",
      "    }",
      "};",
      "",
      "struct Trie {",
      "    TrieNode* root;",
      "",
      "    Trie() {",
      "        root = new TrieNode();",
      "    }",
      "",
      "    // Insert word",
      "    void insert(const string &word) {",
      "        TrieNode* node = root;",
      "        for (char c : word) {",
      "            int idx = c - 'a';",
      "            if (!node->next[idx]) node->next[idx] = new TrieNode();",
      "            node = node->next[idx];",
      "            node->count++;",
      "        }",
      "        node->isEnd = true;",
      "    }",
      "",
      "    // Search full word",
      "    bool search(const string &word) {",
      "        TrieNode* node = root;",
      "        for (char c : word) {",
      "            int idx = c - 'a';",
      "            if (!node->next[idx]) return false;",
      "            node = node->next[idx];",
      "        }",
      "        return node->isEnd;",
      "    }",
      "",
      "    // Check if prefix exists",
      "    bool startsWith(const string &prefix) {",
      "        TrieNode* node = root;",
      "        for (char c : prefix) {",
      "            int idx = c - 'a';",
      "            if (!node->next[idx]) return false;",
      "            node = node->next[idx];",
      "        }",
      "        return true;",
      "    }",
      "",
      "    // Count words with given prefix",
      "    int countPrefix(const string &prefix) {",
      "        TrieNode* node = root;",
      "        for (char c : prefix) {",
      "            int idx = c - 'a';",
      "            if (!node->next[idx]) return 0;",
      "            node = node->next[idx];",
      "        }",
      "        return node->count;",
      "    }",
      "};",
      "",
      "",
      "EXTRA:",
      "// 1. Check if kth bit is set",
      "int chk(int x, int k) { return x >> k & 1; }",
      "",
      "// 2. Print positions of set bits",
      "void prt(int x) { for(int i=0; i<32; ++i) if(x>>i&1) cout<<i<<\" \"; cout<<\"\\n\"; }",
      "",
      "// 3. Count set bits (GCC builtin)",
      "int cnt(int x) { return __builtin_popcount(x); }",
      "",
      "// 4. Check even",
      "bool even(int x) { return !(x & 1); }",
      "",
      "// 5. Set, Unset, Toggle",
      "int set(int x, int k) { return x | (1 << k); }",
      "int unset(int x, int k) { return x & ~(1 << k); }",
      "int tgl(int x, int k) { return x ^ (1 << k); }",
      "",
      "// 6. Check power of 2 (O(1) trick: x has only one bit set)",
      "bool is_pow2(int x) { return x > 0 && !(x & (x - 1)); }",
      "",
      "",
      ""
    ],
    "description": "templates"
  }
}